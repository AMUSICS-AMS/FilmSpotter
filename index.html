<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FilmSpotter - Collaborative Video Review</title>
    <!-- VERSION: 2.40 - Fixed nextFrame duplicate, participants timestamp, chat colors -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .header {
            background: #2d2d2d;
            padding: 12px 20px;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }
        
        .header-info {
            display: flex;
            gap: 15px;
            align-items: center;
            color: #b0b0b0;
            font-size: 14px;
        }
        
        .user-badge {
            background: #0066cc;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 6px 14px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .btn:hover {
            background: #0052a3;
        }
        
        .btn-secondary {
            background: #404040;
        }
        
        .btn-secondary:hover {
            background: #505050;
        }
        
        .btn-danger {
            background: #cc3300;
        }
        
        .btn-danger:hover {
            background: #a32900;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: auto;
        }
        
        .video-setup {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            margin: 40px auto;
        }
        
        .video-setup h2 {
            margin-bottom: 20px;
            color: #fff;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0b0;
        }
        
        .form-group input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #0066cc;
        }
        
        .video-container {
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }
        
        /* Fullscreen video centering */
        .video-container:fullscreen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        .video-container:fullscreen video {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        video {
            width: 100%;
            display: block;
        }
        
        /* Hide download button and prevent context menu */
        video::-webkit-media-controls-download-button {
            display: none !important;
        }
        
        video::-webkit-media-controls-enclosure {
            overflow: hidden;
        }
        
        video::-internal-media-controls-download-button {
            display: none !important;
        }
        
        .timeline-markers {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            height: 8px;
            pointer-events: none;
        }
        
        .timeline-marker {
            position: absolute;
            width: 3px !important;
            min-width: 3px !important;
            max-width: 3px !important;
            height: 8px;
            cursor: pointer;
            pointer-events: all;
            transition: height 0.2s;
            display: block;
        }
        
        .timeline-marker:hover {
            height: 12px;
        }
        
        .video-controls {
            background: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .video-metadata-collapsed {
            margin-bottom: 15px;
        }
        
        .metadata-toggle {
            background: #1a1a1a;
            border: 1px solid #404040;
            color: #b0b0b0;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            width: 100%;
            text-align: left;
            transition: all 0.2s;
        }
        
        .metadata-toggle:hover {
            background: #252525;
            border-color: #505050;
        }
        
        .metadata-toggle span {
            display: inline-block;
            transition: transform 0.2s;
            margin-right: 5px;
        }
        
        .metadata-content {
            margin-top: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        .metadata-content p {
            margin: 5px 0;
            font-size: 13px;
            color: #b0b0b0;
        }
        
        .timecode-display {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .frame-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .frame-btn {
            padding: 6px 12px;
            background: #404040;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .frame-btn:hover {
            background: #505050;
        }
        
        .mark-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 20px;
        }
        
        .mark-controls input {
            flex: 1;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
        }
        
        .sidebar {
            width: 400px;
            background: #2d2d2d;
            border-left: 2px solid #404040;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-tabs {
            display: flex;
            background: #1a1a1a;
        }
        
        .events-filter {
            padding: 10px;
            background: #2d2d2d;
            border-bottom: 1px solid #404040;
        }
        
        .tab {
            flex: 1;
            padding: 12px;
            background: #2d2d2d;
            border: none;
            color: #b0b0b0;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            color: #fff;
            border-bottom-color: #0066cc;
        }
        
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .tab-content .hit-point {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 10px;
            border-left: 3px solid;
        }
        
        .tab-content .hit-point-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .tab-content .hit-point-time {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .marker-label {
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .timecode-editable {
            cursor: pointer;
        }
        
        .timecode-editable:hover {
            text-decoration: underline;
        }
        
        .tab-content .hit-point-actions {
            display: flex;
            gap: 5px;
        }
        
        .icon-btn {
            background: none;
            border: none;
            color: #b0b0b0;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
        }
        
        .icon-btn:hover {
            background: #404040;
            color: #fff;
        }
        
        .tab-content .hit-point-note {
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .tab-content .hit-point-user {
            color: #808080;
            font-size: 12px;
            margin-top: 4px;
        }
        
        .chat-messages {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .chat-message {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
        }
        
        .chat-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .chat-user {
            color: #0066cc;
            font-weight: bold;
            font-size: 13px;
        }
        
        .chat-timestamp {
            font-size: 11px;
            color: #808080;
        }
        
        .chat-text {
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .chat-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
        }
        
        .help-text {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            border-left: 3px solid #0066cc;
        }
        
        .help-text h3 {
            margin-bottom: 10px;
            color: #0066cc;
        }
        
        .help-text p {
            margin-bottom: 8px;
            color: #b0b0b0;
            font-size: 14px;
        }
        
        .help-text kbd {
            background: #404040;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .empty-state {
            text-align: center;
            color: #808080;
            padding: 40px 20px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .fps-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .fps-selector label {
            color: #b0b0b0;
        }
        
        .fps-selector select {
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
        }
        
        .success-message {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #00aa00;
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .error-message {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #cc3300;
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .session-info {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .session-info h3 {
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .session-info p {
            color: #b0b0b0;
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        .session-id {
            background: #2d2d2d;
            padding: 8px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
            color: #fff;
        }
        
        .recent-sessions {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #404040;
        }
        
        .recent-sessions h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #e0e0e0;
        }
        
        .recent-session-item {
            padding: 10px;
            background: #2d2d2d;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .recent-session-item:hover {
            background: #404040;
        }
        
        .recent-session-name {
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 4px;
        }
        
        .recent-session-id {
            font-size: 11px;
            color: #808080;
            font-family: monospace;
        }
        
        .music-metadata {
            transition: all 0.3s;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: #2d2d2d;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: #b0b0b0;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .modal-close:hover {
            color: #fff;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-body .form-group {
            margin-bottom: 15px;
        }
        
        .modal-body .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #b0b0b0;
            font-size: 13px;
        }
        
        .modal-body .form-group input,
        .modal-body .form-group textarea {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
            font-family: inherit;
        }
        
        .modal-body .form-group textarea {
            resize: vertical;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #404040;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Custom Timeline Scrubber */
        .custom-timeline {
            padding: 15px 0;
            background: #1a1a1a;
            border-top: 1px solid #404040;
        }
        
        .timeline-track {
            position: relative;
            height: 40px;
            background: #2a2a2a;
            cursor: pointer;
            margin-bottom: 8px;
        }
        
        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: #0066cc;
            border-radius: 4px 0 0 4px;
            pointer-events: none;
            width: 0%;
        }
        
        .timeline-ticks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .timeline-tick {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            background: #505050;
        }
        
        .timeline-tick.major {
            height: 50%;
            background: #707070;
        }
        
        .timeline-tick-label {
            position: absolute;
            bottom: 55%;
            font-size: 10px;
            color: #808080;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        .timeline-markers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .timeline-marker-dot {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
            border: 2px solid #1a1a1a;
            pointer-events: none;
        }
        
        .timeline-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: white;
            border: 3px solid #0066cc;
            border-radius: 50%;
            cursor: grab;
            pointer-events: none;
            left: 0%;
        }
        
        .timeline-handle:active {
            cursor: grabbing;
        }
        
        .timeline-time {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #b0b0b0;
            font-family: monospace;
            padding: 0 20px;
        }
    </style>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>FilmSpotter</h1>
            </div>
            <div class="header-info hidden" id="headerInfo">
                <span class="user-badge" id="userBadge">User</span>
                <span id="sessionNameDisplay" style="color: #b0b0b0; font-size: 12px; margin: 0 10px;">Session</span>
                <button class="btn btn-secondary" onclick="app.copySessionLink()" style="padding: 4px 8px; font-size: 11px;">Copy Session Link</button>
                <span id="activeUsers" style="color: #b0b0b0; font-size: 12px; cursor: pointer; margin-left: 10px;" title="Click to manage participants" onclick="app.toggleParticipantsPanel()">üë• 0 users</span>
                <span id="connectionStatus">‚óè</span>
            </div>
            <div class="header-controls hidden" id="sessionControls">
                <label style="display: flex; align-items: center; gap: 6px; color: #b0b0b0; font-size: 12px; margin-right: 10px;">
                    <input type="checkbox" id="exportFiltered" checked>
                    Export filtered only
                </label>
                <button class="btn btn-secondary" onclick="app.exportData()">Export Events</button>
                <button class="btn btn-danger" onclick="app.leaveSession()">Leave Session</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="video-section">
                <div id="videoSetup" class="video-setup">
                    <!-- Guest Join Screen (shown when ?session= in URL) -->
                    <div id="guestJoinScreen" class="hidden">
                        <h2>Welcome to FilmSpotter</h2>
                        <p style="color: #b0b0b0; margin-bottom: 30px;">Join the collaborative session</p>
                        
                        <div class="form-group">
                            <label>Project Name</label>
                            <input type="text" id="guestProjectName" placeholder="Loading..." readonly style="background: #1a1a1a; cursor: default;" />
                        </div>
                        
                        <div class="form-group">
                            <label>Session Name</label>
                            <input type="text" id="guestSessionName" placeholder="Loading..." readonly style="background: #1a1a1a; cursor: default;" />
                        </div>
                        
                        <div class="form-group">
                            <label>Your Name</label>
                            <input type="text" id="guestUserName" placeholder="Enter your name" autofocus />
                        </div>
                        
                        <button class="btn" onclick="app.joinAsGuest()">Join Session</button>
                    </div>
                    
                    <!-- Host Setup Screen (shown when no ?session= in URL) -->
                    <div id="hostSetupScreen">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="margin: 0;">Setup FilmSpotter Session</h2>
                            <button class="btn btn-secondary" onclick="app.createNewSession()" style="padding: 6px 12px; font-size: 13px;">+ New Session</button>
                        </div>
                        
                        <div class="form-group">
                            <label>Your Name</label>
                            <input type="text" id="userNameInput" placeholder="Enter your name" />
                        </div>
                        
                        <div class="form-group">
                            <label>Session Name</label>
                            <input type="text" id="sessionNameInput" placeholder="e.g., The Last Stand - Music Spotting" />
                            <p style="font-size: 11px; color: #808080; margin-top: 4px;">Give this session a memorable name so you and your team can find it easily</p>
                        </div>
                        
                        <div class="session-info">
                            <h3>üìã Session ID</h3>
                            <p>This will be generated from your session name. Share the link below with your team:</p>
                            <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                                <div class="session-id" id="sessionIdDisplay" style="flex: 1;">Enter session name above</div>
                                <button class="btn btn-secondary" onclick="app.copySessionLink()" id="copyLinkBtn" style="display: none;">üìã Copy Link</button>
                            </div>
                        </div>
                        
                        <div id="recentSessions" class="recent-sessions hidden">
                            <h3>Recent Sessions</h3>
                            <div id="recentSessionsList"></div>
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 15px;">
                            <label style="display: inline-flex !important; align-items: center; gap: 8px; cursor: pointer; color: #e0e0e0; font-size: 13px; margin-bottom: 0 !important;">
                                <input type="checkbox" id="enablePassword" onchange="app.togglePasswordField()" style="width: auto; margin: 0;">
                                <span>Require password to join (optional)</span>
                            </label>
                            <input type="password" id="sessionPassword" placeholder="Enter session password" class="hidden" style="margin-top: 8px; width: 100%;">
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 15px;">
                            <label style="display: inline-flex !important; align-items: center; gap: 8px; cursor: pointer; color: #e0e0e0; font-size: 13px; margin-bottom: 0 !important;">
                                <input type="checkbox" id="allowAllControl" style="width: auto; margin: 0;">
                                <span>Allow all participants to control and mark</span>
                            </label>
                            <p style="font-size: 11px; color: #808080; margin: 4px 0 0 26px;">If unchecked, only host can control the session and grant permissions</p>
                        </div>
                        
                        <div class="help-text">
                            <h3>Getting Started</h3>
                            
                            <p><strong>üéØ RECOMMENDED: Dropbox (Best for Frame-by-Frame)</strong></p>
                            <p>1. Upload your video to Dropbox</p>
                            <p>2. Right-click ‚Üí Share ‚Üí Copy link</p>
                            <p>3. Paste the ENTIRE link here (tool will convert it automatically)</p>
                            <p>4. Click Load Video</p>
                            <p><em>Example: https://www.dropbox.com/s/abc123/video.mp4?dl=0</em></p>
                        </div>
                        
                        <div class="form-group">
                            <label>Video URL (Dropbox recommended)</label>
                            <input type="text" id="videoUrlInput" placeholder="https://www.dropbox.com/s/..." />
                        </div>
                        <div class="form-group">
                            <label>Project Name</label>
                            <input type="text" id="projectNameInput" placeholder="My Film Project" />
                        </div>
                        <button class="btn" onclick="app.loadVideo()">Load Video</button>
                    </div>
                </div>
                
                <div id="videoPlayer" class="hidden">
                    <div class="video-container">
                        <video id="video" controlslist="nodownload" oncontextmenu="return false;"></video>
                    </div>
                    
                    <!-- Custom Timeline Scrubber -->
                    <div class="custom-timeline">
                        <div class="timeline-track" id="timelineTrack">
                            <div class="timeline-progress" id="timelineProgress"></div>
                            <div class="timeline-ticks" id="timelineTicks"></div>
                            <div class="timeline-markers-container" id="timelineMarkersContainer"></div>
                            <div class="timeline-handle" id="timelineHandle"></div>
                        </div>
                    </div>
                    
                    <div class="video-controls">
                        <div class="timecode-display" id="timecode">00:00:00:00</div>
                        
                        <div class="playback-controls" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="app.togglePlayPause()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚èØ</button>
                            <button class="btn btn-secondary" onclick="app.skipBack()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚è™</button>
                            <button class="btn btn-secondary" onclick="app.skipForward()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚è©</button>
                            <button class="btn btn-secondary" onclick="app.previousFrame()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚óÄ</button>
                            <button class="btn btn-secondary" onclick="app.nextFrame()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚ñ∂</button>
                            <div style="display: flex; align-items: center; gap: 6px; margin-left: 10px;">
                                <span style="font-size: 11px; color: #b0b0b0;">Vol</span>
                                <input type="range" id="volumeControl" min="0" max="100" value="100" onchange="app.setVolume(this.value)" style="width: 60px; cursor: pointer;">
                            </div>
                            <button class="btn btn-secondary" onclick="app.toggleFullscreen()" style="min-width: 40px; line-height: 1; font-size: 16px;">‚õ∂</button>
                        </div>
                        
                        <div class="help-text">
                            <p><kbd>Space</kbd> Play/Pause | <kbd>,</kbd> -5s | <kbd>.</kbd> +5s | <kbd>‚Üê</kbd> Prev Frame | <kbd>‚Üí</kbd> Next Frame | <kbd>M</kbd> Mark</p>
                        </div>
                        
                        <div class="mark-controls">
                            <select id="departmentSelect" onchange="app.updateMarkerTypes()" style="padding: 8px; background: #1a1a1a; border: 1px solid #404040; border-radius: 4px; color: #e0e0e0; font-size: 13px;">
                                <option value="global">Global</option>
                                <option value="music">Music</option>
                                <option value="sound">Sound</option>
                                <option value="vfx">VFX</option>
                                <option value="edit">Edit</option>
                                <option value="color">Color</option>
                            </select>
                            <select id="markerType" style="padding: 8px; background: #1a1a1a; border: 1px solid #404040; border-radius: 4px; color: #e0e0e0; font-size: 13px;">
                                <option value="hit-point">Hit Point</option>
                            </select>
                            <input type="text" id="hitPointNote" placeholder="Add note for marker..." />
                            <button class="btn" onclick="app.markHitPoint()">Mark</button>
                        </div>
                        
                        <div id="musicMetadata" class="music-metadata hidden">
                            <div style="margin-top: 10px; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                                <div style="margin-bottom: 8px;">
                                    <div style="font-size: 11px; color: #b0b0b0; margin-bottom: 4px;">Category:</div>
                                    <label style="display: inline-block; margin-right: 15px; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="category" value="source" style="margin-right: 4px;">
                                        Source Music
                                    </label>
                                    <label style="display: inline-block; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="category" value="underscore" style="margin-right: 4px;">
                                        Underscore
                                    </label>
                                </div>
                                <div>
                                    <div style="font-size: 11px; color: #b0b0b0; margin-bottom: 4px;">Usage:</div>
                                    <label style="display: inline-block; margin-right: 10px; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="usage" value="bg-inst" style="margin-right: 4px;">
                                        BG Instrumental
                                    </label>
                                    <label style="display: inline-block; margin-right: 10px; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="usage" value="bg-vocal" style="margin-right: 4px;">
                                        BG Vocal
                                    </label>
                                    <label style="display: inline-block; margin-right: 10px; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="usage" value="vis-inst" style="margin-right: 4px;">
                                        Visual Instrumental
                                    </label>
                                    <label style="display: inline-block; cursor: pointer; font-size: 12px;">
                                        <input type="checkbox" name="usage" value="vis-vocal" style="margin-right: 4px;">
                                        Visual Vocal
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <div id="videoMetadata" class="video-metadata-collapsed" style="margin-top: 15px;">
                            <button class="metadata-toggle" onclick="app.toggleMetadata()">
                                <span id="metadataToggleIcon">‚ñ∂</span> Video Details
                            </button>
                            <div id="metadataContent" class="metadata-content hidden">
                                <p id="metaResolution">Resolution: Loading...</p>
                                <p id="metaDuration">Duration: Loading...</p>
                                <p id="metaCodec">Codec: Loading...</p>
                                <p id="metaColorSpace">Color Space: Loading...</p>
                                
                                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #404040;">
                                    <div style="margin-bottom: 10px;">
                                        <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #b0b0b0;">Original Frame Rate:</label>
                                        <select id="fpsSelect" onchange="app.updateFPS()" style="padding: 6px; background: #1a1a1a; border: 1px solid #404040; border-radius: 4px; color: #e0e0e0; font-size: 13px;">
                                            <option value="23.976" selected>23.976 fps</option>
                                            <option value="24">24 fps</option>
                                            <option value="25">25 fps</option>
                                            <option value="29.97">29.97 fps</option>
                                            <option value="30">30 fps</option>
                                            <option value="50">50 fps</option>
                                            <option value="60">60 fps</option>
                                        </select>
                                    </div>
                                    
                                    <div style="margin-bottom: 10px;">
                                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;">
                                            <input type="checkbox" id="dropFrame" onchange="app.toggleDropFrame()">
                                            <span>Drop-frame timecode</span>
                                        </label>
                                    </div>
                                    
                                    <div>
                                        <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #b0b0b0;">Start Timecode Offset:</label>
                                        <input type="text" id="timecodeOffset" placeholder="00:00:00:00" 
                                               style="width: 140px; padding: 6px; background: #1a1a1a; border: 1px solid #404040; border-radius: 4px; color: #e0e0e0; font-family: monospace; font-size: 13px;"
                                               onchange="app.updateTimecodeOffset()" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar" style="display: none;">
                <div class="sidebar-tabs">
                    <button class="tab active" onclick="app.switchTab('hitpoints')">Events</button>
                    <button class="tab" onclick="app.switchTab('chat')">Chat</button>
                </div>
                
                <div class="events-filter">
                    <div style="padding: 10px; background: #1a1a1a; border-radius: 4px;">
                        <div style="font-size: 12px; color: #b0b0b0; margin-bottom: 8px;">Filter Departments:</div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-global" value="global" onchange="app.handleDepartmentFilter('global')" checked style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>Global (All)</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-music" value="music" onchange="app.handleDepartmentFilter('music')" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>Music</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-sound" value="sound" onchange="app.handleDepartmentFilter('sound')" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>Sound</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-vfx" value="vfx" onchange="app.handleDepartmentFilter('vfx')" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>VFX</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-edit" value="edit" onchange="app.handleDepartmentFilter('edit')" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>Edit</span>
                            </label>
                            <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                                <input type="checkbox" id="filter-color" value="color" onchange="app.handleDepartmentFilter('color')" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                                <span>Color</span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="padding: 10px; background: #1a1a1a; border-radius: 4px; margin-top: 10px;">
                        <label style="display: inline-flex; align-items: center; cursor: pointer; color: #e0e0e0; font-size: 13px;">
                            <input type="checkbox" id="followEvents" onchange="app.toggleFollowEvents()" style="margin: 0 6px 0 0; width: 14px; height: 14px;">
                            <span>üìç Follow Events</span>
                        </label>
                        <div style="font-size: 11px; color: #808080; margin-top: 4px;">Auto-scroll to current event as video plays</div>
                    </div>
                </div>
                
                <div class="tab-content" id="hitpointsTab">
                    <div id="hitPointsList"></div>
                    <div id="emptyHitPoints" class="empty-state">
                        <p>No events marked yet.</p>
                        <p>Use the "Mark" button or press <kbd>M</kbd> to add one.</p>
                    </div>
                </div>
                
                <div class="tab-content hidden" id="chatTab">
                    <div class="chat-messages" id="chatMessages"></div>
                    <div class="chat-input">
                        <input type="text" id="chatInput" placeholder="Type a message..." onkeypress="app.handleChatEnter(event)" />
                        <button class="btn" onclick="app.sendChat()">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Event Modal -->
    <div id="editModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Event</h3>
                <button class="modal-close" onclick="app.closeEditModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Timecode:</label>
                    <input type="text" id="editTimecode" placeholder="HH:MM:SS:FF">
                </div>
                <div class="form-group">
                    <label>Note:</label>
                    <textarea id="editNote" rows="3" placeholder="Marker note..."></textarea>
                </div>
                <div id="editMusicMetadata" class="hidden">
                    <div class="form-group">
                        <label>Category:</label>
                        <div>
                            <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                <input type="checkbox" name="edit-category" value="source" style="margin-right: 4px;">
                                Source Music
                            </label>
                            <label style="display: inline-block; cursor: pointer;">
                                <input type="checkbox" name="edit-category" value="underscore" style="margin-right: 4px;">
                                Underscore
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Usage:</label>
                        <div>
                            <label style="display: inline-block; margin-right: 10px; cursor: pointer;">
                                <input type="checkbox" name="edit-usage" value="bg-inst" style="margin-right: 4px;">
                                BG Instrumental
                            </label>
                            <label style="display: inline-block; margin-right: 10px; cursor: pointer;">
                                <input type="checkbox" name="edit-usage" value="bg-vocal" style="margin-right: 4px;">
                                BG Vocal
                            </label>
                            <label style="display: inline-block; margin-right: 10px; cursor: pointer;">
                                <input type="checkbox" name="edit-usage" value="vis-inst" style="margin-right: 4px;">
                                Visual Instrumental
                            </label>
                            <label style="display: inline-block; cursor: pointer;">
                                <input type="checkbox" name="edit-usage" value="vis-vocal" style="margin-right: 4px;">
                                Visual Vocal
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeEditModal()">Cancel</button>
                <button class="btn" onclick="app.saveEditedEvent()">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Participants Panel -->
    <div id="participantsPanel" class="modal hidden">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3>üë• Participants</h3>
                <button class="modal-close" onclick="app.toggleParticipantsPanel()">√ó</button>
            </div>
            <div class="modal-body" id="participantsList" style="max-height: 400px; overflow-y: auto;">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <!-- Export Format Selection Modal -->
    <div id="exportModal" class="modal hidden">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3>Select Export Formats</h3>
                <button class="close-btn" onclick="app.closeExportModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #b0b0b0;">Choose which formats to export:</p>
                
                <!-- FREE -->
                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; cursor: pointer;">
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" id="exportCSV" checked style="margin-right: 8px;">
                        <span>CSV (Spreadsheet)</span>
                    </div>
                    <span style="font-size: 10px; color: #4CAF50; background: rgba(76, 175, 80, 0.1); padding: 2px 6px; border-radius: 3px;">FREE</span>
                </label>
                
                <!-- PAID TIER -->
                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; cursor: not-allowed; opacity: 0.5;">
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" id="exportJSON" disabled style="margin-right: 8px;">
                        <span>JSON (Data)</span>
                    </div>
                    <span style="font-size: 10px; color: #FFA726; background: rgba(255, 167, 38, 0.1); padding: 2px 6px; border-radius: 3px;">INDIE</span>
                </label>
                
                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; cursor: not-allowed; opacity: 0.5;">
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" id="exportEDL" disabled style="margin-right: 8px;">
                        <span>EDL (Edit Decision List)</span>
                    </div>
                    <span style="font-size: 10px; color: #FFA726; background: rgba(255, 167, 38, 0.1); padding: 2px 6px; border-radius: 3px;">INDIE</span>
                </label>
                
                <label style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; cursor: not-allowed; opacity: 0.5;">
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" id="exportMIDI" disabled style="margin-right: 8px;">
                        <span>MIDI (DAW Markers)</span>
                    </div>
                    <span style="font-size: 10px; color: #FFA726; background: rgba(255, 167, 38, 0.1); padding: 2px 6px; border-radius: 3px;">INDIE</span>
                </label>
                
                <button class="btn" onclick="app.confirmExport()" style="width: 100%; margin-bottom: 10px;">Export Selected</button>
                <button class="btn btn-secondary" onclick="app.showUpgradeModal()" style="width: 100%;">Unlock All Exports ‚Üí</button>
            </div>
        </div>
    </div>
    
    <!-- Upgrade Modal -->
    <div id="upgradeModal" class="modal hidden">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3>Upgrade to Indie Plan</h3>
                <button class="close-btn" onclick="app.closeUpgradeModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #e0e0e0;">Unlock all export formats and support FilmSpotter development!</p>
                
                <div style="background: #2a2a2a; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #FFA726;">Indie Plan - $5/month</h4>
                    <ul style="list-style: none; padding: 0; margin: 0;">
                        <li style="padding: 8px 0; border-bottom: 1px solid #404040;">‚úì MIDI Export (DAW Markers)</li>
                        <li style="padding: 8px 0; border-bottom: 1px solid #404040;">‚úì JSON Export (Data)</li>
                        <li style="padding: 8px 0; border-bottom: 1px solid #404040;">‚úì EDL Export (Edit Decision)</li>
                        <li style="padding: 8px 0;">‚úì All Free Features</li>
                    </ul>
                </div>
                
                <p style="color: #b0b0b0; font-size: 14px; margin-bottom: 20px;">Coming soon! Join the waitlist to be notified when paid plans launch.</p>
                
                <button class="btn" onclick="app.joinWaitlist()" style="width: 100%;">Join Waitlist</button>
            </div>
        </div>
    </div>
    
    <!-- Leave Session Modal -->
    <div id="leaveSessionModal" class="modal hidden">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3>Leave Session</h3>
                <button class="close-btn" onclick="app.closeLeaveSessionModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #e0e0e0;">You are the host of this session. Choose an option:</p>
                <button class="btn btn-danger" onclick="app.endSessionForAll()" style="width: 100%; margin-bottom: 10px; padding: 12px;">
                    End Session For Everyone
                    <div style="font-size: 11px; color: #ffcccc; margin-top: 4px;">Deletes all markers, chat, and session data</div>
                </button>
                <button class="btn btn-secondary" onclick="app.leaveAndTransferHost()" style="width: 100%; margin-bottom: 10px; padding: 12px;">
                    Leave & Transfer Host
                    <div style="font-size: 11px; color: #cccccc; margin-top: 4px;">Session continues, next person becomes host</div>
                </button>
                <button class="btn" onclick="app.closeLeaveSessionModal()" style="width: 100%; padding: 12px;">
                    Cancel (Stay in Session)
                </button>
            </div>
        </div>
    </div>
    
    <!-- Guest Leave Confirmation Modal -->
    <div id="guestLeaveModal" class="modal hidden">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3>Leave Session</h3>
                <button class="close-btn" onclick="app.closeGuestLeaveModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #e0e0e0;">Are you sure you want to leave this session?</p>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-danger" onclick="app.confirmLeaveAsGuest()" style="flex: 1;">Leave Session</button>
                    <button class="btn btn-secondary" onclick="app.closeGuestLeaveModal()" style="flex: 1;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            fps: 23.976,
            video: null,
            sessionId: null,
            sessionName: '', // Friendly display name
            userName: 'Anonymous',
            updateInterval: null,
            detectedFPS: null,
            activeUsers: [],
            timecodeOffset: 0, // offset in seconds
            useDropFrame: false, // drop-frame timecode mode
            currentDepartment: 'music', // Current department for marking
            eventsFilter: 'global', // Current filter for events display
            activeFilters: ['global'], // Array of active department filters
            editingEventId: null, // ID of event being edited
            isHost: false, // Is current user the host
            canMark: true, // Can this user mark events
            canChat: true, // Can this user send chat messages
            canControl: true, // Can this user control playback
            sessionPassword: null, // Session password if set
            allowAllControl: true, // Whether all users can control
            userRole: 'viewer', // current user's role: 'host', 'co-host', 'viewer'
            currentHighlightedEventId: null, // Track currently highlighted event to prevent flashing
            lastHighlightUpdate: 0, // Timestamp of last highlight update for throttling
            followEvents: false, // Whether to auto-scroll to current event
            userColorMap: {}, // Map of username -> color
            nextColorIndex: 0, // Next color to assign
            
            // Firebase configuration
            firebaseConfig: {
                apiKey: "AIzaSyDRuHGzq2Rsno5wN_WAAbRARQy1lfMZq9M",
                authDomain: "filmspotter.firebaseapp.com",
                projectId: "filmspotter",
                storageBucket: "filmspotter.firebasestorage.app",
                messagingSenderId: "357426669445",
                appId: "1:357426669445:web:2bfc11f41263f93b0946ec"
            },
            db: null, // Firestore database reference
            unsubscribeListeners: [], // Store listener unsubscribe functions
            participantHeartbeat: null, // Interval for participant heartbeat
            myParticipantId: null, // This user's participant ID
            lastParticipantCount: -1, // Track last count (-1 means never set, forces first update)
            participantUpdateCount: 0, // Count how many times we've updated
            
            // Department configuration
            departments: {
                music: {
                    name: 'Music',
                    color: '#ffcc00', // Yellow/Gold
                    markers: [
                        { value: 'music-in', label: 'Music In', color: '#ffcc00' },
                        { value: 'music-out', label: 'Music Out', color: '#ff9900' },
                        { value: 'hit-point', label: 'Hit Point', color: '#ffeb3b' },
                        { value: 'song-in', label: 'Song In', color: '#ffd700' },
                        { value: 'song-out', label: 'Song Out', color: '#ffb300' },
                        { value: 'audio-ref', label: 'Audio Reference', color: '#ffe066' }
                    ]
                },
                sound: {
                    name: 'Sound',
                    color: '#00ccff', // Blue/Cyan
                    markers: [
                        { value: 'music-in', label: 'Music In', color: '#00ccff' },
                        { value: 'music-out', label: 'Music Out', color: '#0099cc' },
                        { value: 'adr', label: 'ADR', color: '#33d4ff' },
                        { value: 'walla', label: 'Walla', color: '#66ddff' },
                        { value: 'backgrounds', label: 'Backgrounds', color: '#00b8e6' },
                        { value: 'foley', label: 'Foley', color: '#00a3d1' },
                        { value: 'clean-up', label: 'Clean Up', color: '#008fb8' }
                    ]
                },
                vfx: {
                    name: 'VFX',
                    color: '#9933ff', // Purple/Magenta
                    markers: [
                        { value: 'shot', label: 'Shot', color: '#9933ff' }
                    ]
                },
                edit: {
                    name: 'Edit',
                    color: '#00cc00', // Green
                    markers: [
                        { value: 'shot', label: 'Shot', color: '#00cc00' }
                    ]
                },
                color: {
                    name: 'Color',
                    color: '#ff6600', // Orange
                    markers: [
                        { value: 'note', label: 'Note', color: '#ff6600' }
                    ]
                }
            },
            
            // Simple in-memory storage for this demo
            // In production, this would use Firebase or another real-time database
            storage: {
                hitPoints: [],
                chatMessages: []
            },
            
            async init() {
                this.video = document.getElementById('video');
                
                // Initialize Firebase
                try {
                    firebase.initializeApp(this.firebaseConfig);
                    this.db = firebase.firestore();
                    console.log('‚úÖ Firebase initialized successfully');
                    this.showMessage('‚úì Connected to Firebase - real-time sync enabled');
                } catch (error) {
                    console.error('‚ùå Firebase initialization failed:', error);
                    this.showMessage('‚ö†Ô∏è Firebase connection failed - using local storage only', true);
                }
                
                // Check URL for session parameter
                const urlParams = new URLSearchParams(window.location.search);
                const urlSessionId = urlParams.get('session');
                
                // Determine if this is a guest joining via link
                const isGuest = !!urlSessionId;
                
                if (isGuest) {
                    // Show guest screen, hide host screen
                    document.getElementById('guestJoinScreen').classList.remove('hidden');
                    document.getElementById('hostSetupScreen').classList.add('hidden');
                    
                    // Join session from URL
                    this.sessionId = urlSessionId;
                    localStorage.setItem('film-spotter-session-id', urlSessionId);
                    
                    // Load session data and populate guest fields
                    if (this.db) {
                        await this.loadSessionDataForGuest(urlSessionId);
                    }
                } else {
                    // Show host screen, hide guest screen
                    document.getElementById('guestJoinScreen').classList.add('hidden');
                    document.getElementById('hostSetupScreen').classList.remove('hidden');
                    
                    // Get or create session
                    this.sessionId = this.getOrCreateSessionId();
                    
                    document.getElementById('sessionIdDisplay').textContent = this.sessionId;
                    
                    // Show recent sessions on setup screen
                    this.showRecentSessions();
                    
                    // Add session name input listener
                    document.getElementById('sessionNameInput').addEventListener('input', (e) => {
                        this.updateSessionIdPreview(e.target.value);
                    });
                }
                
                // Set up Firebase real-time listeners NOW (with sessionId set)
                if (this.db && this.sessionId) {
                    this.setupFirebaseListeners();
                }
                
                // Initialize department selector to Global by default
                document.getElementById('departmentSelect').value = 'global';
                this.activeFilters = ['global'];
                this.updateMarkerTypes();
                
                this.setupEventListeners();
                await this.loadUserName();
                if (!isGuest) {
                    await this.loadSession();
                }
                this.startUpdateLoop();
            },
            
            async loadSessionDataForGuest(sessionId) {
                try {
                    const sessionRef = this.db.collection('sessions').doc(sessionId);
                    const doc = await sessionRef.get();
                    
                    if (doc.exists) {
                        const data = doc.data();
                        
                        // Populate guest fields
                        document.getElementById('guestSessionName').value = data.sessionName || sessionId;
                        document.getElementById('guestProjectName').value = data.projectName || 'Untitled Project';
                        
                        console.log('‚úÖ Loaded session data for guest');
                    } else {
                        document.getElementById('guestSessionName').value = sessionId;
                        document.getElementById('guestProjectName').value = 'Session not found';
                        console.log('iÔ∏è Session exists but has no metadata yet');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading session data:', error);
                    document.getElementById('guestSessionName').value = sessionId;
                    document.getElementById('guestProjectName').value = 'Error loading session';
                }
            },
            
            async joinAsGuest() {
                const userName = document.getElementById('guestUserName').value.trim();
                
                if (!userName) {
                    alert('Please enter your name');
                    return;
                }
                
                this.userName = userName;
                localStorage.setItem('film-spotter-username', userName);
                
                // Load the session data from Firebase to check password
                try {
                    const sessionRef = this.db.collection('sessions').doc(this.sessionId);
                    const doc = await sessionRef.get();
                    
                    if (doc.exists) {
                        const data = doc.data();
                        
                        // Check if session has password
                        if (data.password) {
                            const enteredPassword = prompt('This session is password protected. Enter password:');
                            if (enteredPassword !== data.password) {
                                alert('Incorrect password. Access denied.');
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking password:', error);
                }
                
                // Load the session data from Firebase
                await this.loadSessionFromFirebase(this.sessionId);
                
                // Check if video URL was loaded
                const videoUrl = document.getElementById('videoUrlInput').value;
                const projectName = document.getElementById('projectNameInput').value;
                
                if (videoUrl && projectName) {
                    // Trigger the actual video loading
                    await this.loadVideo();
                } else {
                    this.showMessage('‚ö†Ô∏è Session has no video loaded yet. Waiting for host to start...', true);
                }
                
                console.log(`üë§ Joined as guest: ${userName}`);
            },
            
            getOrCreateSessionId() {
                let sessionId = localStorage.getItem('film-spotter-session-id');
                if (!sessionId) {
                    sessionId = 'session-' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('film-spotter-session-id', sessionId);
                }
                return sessionId;
            },
            
            updateSessionIdPreview(sessionName) {
                const sessionIdInput = document.getElementById('sessionIdDisplay');
                const copyBtn = document.getElementById('copyLinkBtn');
                
                if (sessionName.trim()) {
                    // Show the actual random session ID, not a converted name
                    sessionIdInput.textContent = this.sessionId;
                    copyBtn.style.display = 'inline-block';
                } else {
                    sessionIdInput.textContent = 'Enter session name above';
                    copyBtn.style.display = 'none';
                }
            },
            
            copySessionLink() {
                if (!this.sessionId) {
                    this.showMessage('‚ö†Ô∏è No active session to share', true);
                    return;
                }
                
                // Get base URL without query parameters
                const baseUrl = window.location.origin + window.location.pathname;
                const sessionLink = `${baseUrl}?session=${this.sessionId}`;
                
                console.log(`üìã Base URL: ${baseUrl}`);
                console.log(`üìã Session ID: ${this.sessionId}`);
                console.log(`üìã Full link: ${sessionLink}`);
                
                // Copy to clipboard
                navigator.clipboard.writeText(sessionLink).then(() => {
                    this.showMessage(`‚úì Session link copied: ${this.sessionId}`);
                }).catch((error) => {
                    console.error('Clipboard error:', error);
                    // Fallback for older browsers
                    prompt('Copy this link to share:', sessionLink);
                });
            },
            
            showRecentSessions() {
                const recentSessionsDiv = document.getElementById('recentSessions');
                const listDiv = document.getElementById('recentSessionsList');
                
                // Get recent sessions from localStorage
                const recentSessions = JSON.parse(localStorage.getItem('film-spotter-recent-sessions') || '[]');
                
                if (recentSessions.length > 0) {
                    recentSessionsDiv.classList.remove('hidden');
                    listDiv.innerHTML = recentSessions.slice(0, 5).map(session => `
                        <div class="recent-session-item" onclick="app.joinRecentSession('${session.id}')">
                            <div class="recent-session-name">${session.name || 'Unnamed Session'}</div>
                            <div class="recent-session-id">${session.id}</div>
                        </div>
                    `).join('');
                } else {
                    recentSessionsDiv.classList.add('hidden');
                }
            },
            
            joinRecentSession(sessionId) {
                // Set session ID
                this.sessionId = sessionId;
                localStorage.setItem('film-spotter-session-id', sessionId);
                
                // Update display
                document.getElementById('sessionIdDisplay').textContent = sessionId;
                
                // Set up listeners for this session
                if (this.db && this.sessionId) {
                    // Clear any existing listeners first
                    this.unsubscribeListeners.forEach(unsub => unsub());
                    this.unsubscribeListeners = [];
                    
                    // Set up new listeners for this session
                    this.setupFirebaseListeners();
                }
                
                // Load session data from Firebase
                if (this.db) {
                    this.loadSessionFromFirebase(sessionId);
                }
                
                this.showMessage(`‚úì Switched to session: ${sessionId}`);
            },
            
            saveSessionToRecents(sessionId, sessionName) {
                const recentSessions = JSON.parse(localStorage.getItem('film-spotter-recent-sessions') || '[]');
                
                // Remove if already exists
                const filtered = recentSessions.filter(s => s.id !== sessionId);
                
                // Add to front
                filtered.unshift({
                    id: sessionId,
                    name: sessionName,
                    timestamp: Date.now()
                });
                
                // Keep only last 10
                const trimmed = filtered.slice(0, 10);
                
                localStorage.setItem('film-spotter-recent-sessions', JSON.stringify(trimmed));
            },
            
            async loadUserName() {
                const savedName = localStorage.getItem('film-spotter-username');
                if (savedName) {
                    this.userName = savedName;
                    document.getElementById('userNameInput').value = savedName;
                    document.getElementById('userBadge').textContent = savedName;
                }
            },
            
            setupEventListeners() {
                // Don't setup custom timeline here - wait until video loads
                
                // Save username when it changes
                document.getElementById('userNameInput').addEventListener('change', (e) => {
                    this.userName = e.target.value.trim() || 'Anonymous';
                    localStorage.setItem('film-spotter-username', this.userName);
                    document.getElementById('userBadge').textContent = this.userName;
                });
                
                // Make category checkboxes behave like radio buttons
                document.querySelectorAll('input[name="category"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            document.querySelectorAll('input[name="category"]').forEach(cb => {
                                if (cb !== e.target) cb.checked = false;
                            });
                        }
                    });
                });
                
                // Make usage checkboxes behave like radio buttons
                document.querySelectorAll('input[name="usage"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            document.querySelectorAll('input[name="usage"]').forEach(cb => {
                                if (cb !== e.target) cb.checked = false;
                            });
                        }
                    });
                });
                
                // Make edit modal category checkboxes behave like radio buttons
                document.querySelectorAll('input[name="edit-category"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            document.querySelectorAll('input[name="edit-category"]').forEach(cb => {
                                if (cb !== e.target) cb.checked = false;
                            });
                        }
                    });
                });
                
                // Make edit modal usage checkboxes behave like radio buttons
                document.querySelectorAll('input[name="edit-usage"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            document.querySelectorAll('input[name="edit-usage"]').forEach(cb => {
                                if (cb !== e.target) cb.checked = false;
                            });
                        }
                    });
                });
                
                // Double-click timecode to edit and jump
                const timecodeDisplay = document.getElementById('timecode');
                timecodeDisplay.style.cursor = 'pointer';
                timecodeDisplay.addEventListener('click', () => {
                    const currentTC = timecodeDisplay.textContent;
                    timecodeDisplay.contentEditable = 'true';
                    timecodeDisplay.style.background = '#404040';
                    timecodeDisplay.style.outline = '2px solid #0066cc';
                    timecodeDisplay.focus();
                    
                    // Select all text
                    const range = document.createRange();
                    range.selectNodeContents(timecodeDisplay);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                });
                
                document.getElementById('timecode').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.jumpToFrame(e.target.textContent);
                        this.syncPlaybackState(); // Sync to other users
                        e.target.contentEditable = 'false';
                        e.target.style.background = '';
                        e.target.style.outline = '';
                        e.target.blur();
                    } else if (e.key === 'Escape') {
                        e.target.contentEditable = 'false';
                        e.target.style.background = '';
                        e.target.style.outline = '';
                        e.target.blur();
                        this.updateTimecode();
                    }
                });
                
                document.getElementById('timecode').addEventListener('blur', (e) => {
                    e.target.contentEditable = 'false';
                    e.target.style.background = '';
                    e.target.style.outline = '';
                    this.updateTimecode();
                });
                
                // Video time update
                this.video.addEventListener('timeupdate', () => {
                    this.updateTimecode();
                    this.updateTimelineMarkers();
                    this.highlightCurrentEvent();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts if user is typing in an input field
                    const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
                    
                    if (isTyping) {
                        return; // Let the user type normally
                    }
                    
                    // Prevent default for specific keys only when not typing
                    if (['Space', 'ArrowLeft', 'ArrowRight', 'Comma', 'Period'].includes(e.code)) {
                        e.preventDefault();
                    }
                    
                    if (e.code === 'Space') {
                        this.togglePlayPause();
                    } else if (e.code === 'ArrowLeft') {
                        this.previousFrame();
                    } else if (e.code === 'ArrowRight') {
                        this.nextFrame();
                    } else if (e.code === 'Comma') {
                        // , key = jump back 5 seconds
                        if (!this.canControl) {
                            this.showMessage('‚õî You do not have permission to control playback', true);
                            return;
                        }
                        this.video.currentTime = Math.max(0, this.video.currentTime - 5);
                        this.syncPlaybackState();
                    } else if (e.code === 'Period') {
                        // . key = jump forward 5 seconds
                        if (!this.canControl) {
                            this.showMessage('‚õî You do not have permission to control playback', true);
                            return;
                        }
                        this.video.currentTime = Math.min(this.video.duration, this.video.currentTime + 5);
                        this.syncPlaybackState();
                    } else if (e.code === 'KeyM') {
                        this.markHitPoint();
                    }
                });
            },
            
            setupCustomTimeline() {
                const track = document.getElementById('timelineTrack');
                const progress = document.getElementById('timelineProgress');
                const handle = document.getElementById('timelineHandle');
                let isDragging = false;
                
                if (!track || !progress || !handle) {
                    console.error('‚ùå Timeline elements not found');
                    return;
                }
                
                // Update timeline visuals
                const updateTimelineUI = () => {
                    if (!this.video) {
                        console.log('‚ö†Ô∏è No video element');
                        return;
                    }
                    
                    // Update current time
                    const currentDisplay = document.getElementById('currentTimeDisplay');
                    if (currentDisplay) {
                        currentDisplay.textContent = this.formatTimecode(this.video.currentTime);
                    }
                    
                    // Update duration and progress bar when duration available
                    if (this.video.duration && isFinite(this.video.duration)) {
                        const durationDisplay = document.getElementById('durationDisplay');
                        if (durationDisplay) {
                            durationDisplay.textContent = this.formatTimecode(this.video.duration);
                            durationDisplay.style.opacity = '1'; // Show it once loaded
                        }
                        
                        const percent = (this.video.currentTime / this.video.duration) * 100;
                        progress.style.width = `${percent}%`;
                        handle.style.left = `${percent}%`;
                        console.log(`üìä Timeline: ${percent.toFixed(1)}% (${this.video.currentTime.toFixed(2)}s / ${this.video.duration.toFixed(2)}s)`);
                    } else {
                        console.log('‚ö†Ô∏è Duration not ready:', this.video.duration);
                    }
                };
                
                // Seek to position
                const seekToPosition = (clientX) => {
                    if (!this.canControl) {
                        this.showMessage('‚õî You do not have permission to control playback', true);
                        return;
                    }
                    if (!this.video || !this.video.duration) return;
                    
                    const rect = track.getBoundingClientRect();
                    const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                    const newTime = percent * this.video.duration;
                    
                    this.video.currentTime = newTime;
                    this.syncPlaybackState();
                    updateTimelineUI();
                };
                
                // Mouse/touch handlers
                track.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    seekToPosition(e.clientX);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        seekToPosition(e.clientX);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                // Add tooltip on hover
                const tooltip = document.createElement('div');
                tooltip.style.cssText = 'position: absolute; bottom: 105%; left: 0; background: rgba(0,0,0,0.9); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-family: monospace; pointer-events: none; opacity: 0; transition: opacity 0.2s; white-space: nowrap; z-index: 10;';
                track.appendChild(tooltip);
                
                track.addEventListener('mousemove', (e) => {
                    const rect = track.getBoundingClientRect();
                    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    
                    if (this.video && this.video.duration && isFinite(this.video.duration)) {
                        const time = percent * this.video.duration;
                        const tc = this.formatTimecode(time);
                        tooltip.textContent = tc;
                    } else {
                        // Show percentage if duration not ready
                        tooltip.textContent = `${(percent * 100).toFixed(0)}%`;
                    }
                    
                    tooltip.style.left = `${percent * 100}%`;
                    tooltip.style.transform = 'translateX(-50%)';
                    tooltip.style.opacity = '1';
                });
                
                track.addEventListener('mouseleave', () => {
                    tooltip.style.opacity = '0';
                });
                
                // Update on video timeupdate
                this.video.addEventListener('timeupdate', () => {
                    updateTimelineUI();
                });
                
                this.video.addEventListener('loadedmetadata', () => {
                    console.log('üìπ Metadata loaded - Duration:', this.video.duration);
                    updateTimelineUI();
                    this.generateTimelineTicks();
                    // Update markers when metadata loads
                    if (this.updateCustomTimelineMarkers) {
                        this.updateCustomTimelineMarkers();
                    }
                });
                
                this.video.addEventListener('canplay', () => {
                    console.log('üìπ Video can play');
                    updateTimelineUI();
                });
                
                // Force initial call after a short delay
                setTimeout(() => {
                    console.log('‚è±Ô∏è Force update timeline');
                    updateTimelineUI();
                }, 100);
                
                // Check for duration every 500ms for up to 10 seconds
                let durationCheckCount = 0;
                const durationCheckInterval = setInterval(() => {
                    durationCheckCount++;
                    if (this.video.duration && isFinite(this.video.duration)) {
                        console.log(`‚úÖ Duration loaded: ${this.video.duration}s`);
                        updateTimelineUI();
                        this.generateTimelineTicks();
                        clearInterval(durationCheckInterval);
                    } else if (durationCheckCount >= 20) {
                        console.warn('‚ö†Ô∏è Duration never loaded after 10 seconds');
                        clearInterval(durationCheckInterval);
                    }
                }, 500);
                
                // Generate timeline ticks
                this.generateTimelineTicks = () => {
                    if (!this.video || !this.video.duration || !isFinite(this.video.duration)) {
                        console.log('‚ö†Ô∏è Skipping tick generation, duration not ready');
                        return;
                    }
                    
                    const container = document.getElementById('timelineTicks');
                    if (!container) return;
                    container.innerHTML = '';
                    
                    const duration = this.video.duration;
                    console.log(`üìè Generating quarter markers for duration: ${duration}s`);
                    
                    // Add simple quarter markers (25%, 50%, 75%)
                    [0.25, 0.5, 0.75].forEach(fraction => {
                        const percent = fraction * 100;
                        const tick = document.createElement('div');
                        tick.className = 'timeline-tick major';
                        tick.style.left = `${percent}%`;
                        container.appendChild(tick);
                    });
                };
                
                // Update markers on timeline
                this.updateCustomTimelineMarkers = () => {
                    if (!this.video || !this.video.duration) return;
                    
                    const container = document.getElementById('timelineMarkersContainer');
                    container.innerHTML = '';
                    
                    this.storage.hitPoints.forEach(hp => {
                        const percent = (hp.time / this.video.duration) * 100;
                        const dot = document.createElement('div');
                        dot.className = 'timeline-marker-dot';
                        dot.style.left = `${percent}%`;
                        dot.title = `${hp.timecode} - ${hp.note}`;
                        
                        // Set color based on department
                        const deptColors = {
                            music: '#ffcc00',    // Yellow/Gold
                            sound: '#00ccff',    // Blue/Cyan
                            vfx: '#9933ff',      // Purple/Magenta
                            edit: '#00cc00',     // Green
                            color: '#ff6600'     // Orange
                        };
                        dot.style.background = deptColors[hp.department] || 'white';
                        
                        container.appendChild(dot);
                    });
                };
            },
            
            async loadSession() {
                try {
                    const sessionData = localStorage.getItem('film-spotter-session');
                    if (sessionData) {
                        const session = JSON.parse(sessionData);
                        if (session.videoUrl) {
                            document.getElementById('videoUrlInput').value = session.videoUrl;
                            document.getElementById('projectNameInput').value = session.projectName || '';
                        }
                    }
                    
                    // Load saved timecode offset
                    const savedOffset = localStorage.getItem('film-spotter-offset-' + this.sessionId);
                    if (savedOffset) {
                        this.timecodeOffset = parseFloat(savedOffset);
                        const time = this.timecodeOffset;
                        const hours = Math.floor(time / 3600);
                        const minutes = Math.floor((time % 3600) / 60);
                        const seconds = Math.floor(time % 60);
                        const frames = Math.round((time % 1) * this.fps);
                        const tc = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(frames).padStart(2, '0')}`;
                        document.getElementById('timecodeOffset').value = tc;
                    }
                } catch (error) {
                    console.log('No existing session found');
                }
                
                // Load hit points and chat
                this.loadStoredData();
                await this.refreshHitPoints();
                await this.refreshChat();
            },
            
            loadStoredData() {
                try {
                    const hitPoints = localStorage.getItem('film-spotter-hitpoints-' + this.sessionId);
                    if (hitPoints) {
                        this.storage.hitPoints = JSON.parse(hitPoints);
                    }
                    
                    const chat = localStorage.getItem('film-spotter-chat-' + this.sessionId);
                    if (chat) {
                        this.storage.chatMessages = JSON.parse(chat);
                    }
                } catch (error) {
                    console.log('Error loading stored data');
                }
            },
            
            async saveMarkerToFirebase(marker) {
                if (!this.db || !this.sessionId) {
                    console.warn('‚ö†Ô∏è Firebase not initialized or no session ID');
                    console.warn('   this.db:', this.db ? 'EXISTS' : 'NULL');
                    console.warn('   this.sessionId:', this.sessionId);
                    return;
                }
                
                console.log(`üíæ Attempting to save marker to Firebase...`);
                console.log(`   Session: ${this.sessionId}`);
                console.log(`   Marker ID: ${marker.id}`);
                console.log(`   User: ${this.userName}`);
                
                try {
                    const path = `sessions/${this.sessionId}/markers/${marker.id}`;
                    console.log(`   Path: ${path}`);
                    
                    // Save marker as individual document in subcollection
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('markers').doc(marker.id).set(marker);
                    
                    console.log(`‚úÖ Saved marker ${marker.id} to Firebase by ${this.userName}`);
                } catch (error) {
                    console.error('‚ùå Error saving marker to Firebase:', error);
                    console.error('   Error code:', error.code);
                    console.error('   Error message:', error.message);
                    this.showMessage(`‚ùå Failed to save marker: ${error.message}`, true);
                    throw error; // Re-throw so caller knows it failed
                }
            },
            
            async saveChatToFirebase(message) {
                if (!this.db || !this.sessionId) {
                    console.warn('‚ö†Ô∏è Firebase not initialized or no session ID');
                    console.warn('   this.db:', this.db ? 'EXISTS' : 'NULL');
                    console.warn('   this.sessionId:', this.sessionId);
                    return;
                }
                
                console.log(`üí¨ Attempting to save chat to Firebase...`);
                console.log(`   Session: ${this.sessionId}`);
                console.log(`   Message ID: ${message.id}`);
                console.log(`   User: ${this.userName}`);
                
                try {
                    const path = `sessions/${this.sessionId}/chat/${message.id}`;
                    console.log(`   Path: ${path}`);
                    
                    // Save chat message as individual document in subcollection
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('chat').doc(message.id).set(message);
                    
                    console.log(`‚úÖ Saved chat message ${message.id} to Firebase by ${this.userName}`);
                } catch (error) {
                    console.error('‚ùå Error saving chat to Firebase:', error);
                    console.error('   Error code:', error.code);
                    console.error('   Error message:', error.message);
                    this.showMessage(`‚ùå Failed to send message: ${error.message}`, true);
                    throw error;
                }
            },
            
            saveStoredData() {
                try {
                    // Save to localStorage as backup
                    localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                    localStorage.setItem('film-spotter-chat-' + this.sessionId, JSON.stringify(this.storage.chatMessages));
                    
                    // Sync to Firebase if connected
                    if (this.db) {
                        this.syncToFirebase();
                    }
                } catch (error) {
                    console.error('Error saving data:', error);
                }
            },
            
            async syncToFirebase() {
                if (!this.db || !this.sessionId) return;
                
                try {
                    const sessionRef = this.db.collection('sessions').doc(this.sessionId);
                    
                    // Only sync playback state and offset at session level
                    // Markers and chat are handled via subcollections
                    await sessionRef.set({
                        playbackState: {
                            isPlaying: !this.video.paused,
                            currentTime: this.video.currentTime,
                            updatedBy: this.userName,
                            timestamp: Date.now()
                        },
                        timecodeOffset: this.timecodeOffset,
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                    
                    console.log(`‚úÖ Synced playback state to Firebase`);
                } catch (error) {
                    console.error('‚ùå Firebase sync error:', error);
                }
            },
            
            setupFirebaseListeners() {
                if (!this.db || !this.sessionId) return;
                
                console.log(`üî• Setting up Firebase listeners for session: ${this.sessionId}, user: ${this.userName}`);
                
                const sessionRef = this.db.collection('sessions').doc(this.sessionId);
                
                // Listen for MARKERS subcollection changes
                const markersUnsubscribe = sessionRef.collection('markers').onSnapshot((snapshot) => {
                    console.log(`üìç Markers snapshot: ${snapshot.docChanges().length} changes`);
                    snapshot.docChanges().forEach((change) => {
                        const marker = change.doc.data();
                        console.log(`Marker change type: ${change.type}, marker:`, marker);
                        
                        if (change.type === 'added') {
                            // Check if we already have this marker
                            const exists = this.storage.hitPoints.find(hp => hp.id === marker.id);
                            if (!exists) {
                                console.log(`‚ûï New marker added: ${marker.id} by ${marker.user} at ${marker.timecode}`);
                                this.storage.hitPoints.push(marker);
                                this.storage.hitPoints.sort((a, b) => a.time - b.time);
                                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                                this.refreshHitPoints();
                            } else {
                                console.log(`‚ûï Marker ${marker.id} already exists, skipping`);
                            }
                        } else if (change.type === 'modified') {
                            // Update existing marker
                            const index = this.storage.hitPoints.findIndex(hp => hp.id === marker.id);
                            if (index !== -1) {
                                console.log(`‚úèÔ∏è Marker updated: ${marker.id}`);
                                this.storage.hitPoints[index] = marker;
                                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                                this.refreshHitPoints();
                            }
                        } else if (change.type === 'removed') {
                            // Remove marker
                            console.log(`üóëÔ∏è Marker removed: ${marker.id}`);
                            this.storage.hitPoints = this.storage.hitPoints.filter(hp => hp.id !== marker.id);
                            localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                            this.refreshHitPoints();
                        }
                    });
                }, (error) => {
                    console.error('‚ùå Markers listener error:', error);
                });
                
                // Listen for CHAT subcollection changes
                const chatUnsubscribe = sessionRef.collection('chat').onSnapshot((snapshot) => {
                    console.log(`üí¨ Chat snapshot: ${snapshot.docChanges().length} changes`);
                    snapshot.docChanges().forEach((change) => {
                        const message = change.doc.data();
                        console.log(`Chat change type: ${change.type}, message:`, message);
                        
                        if (change.type === 'added') {
                            const exists = this.storage.chatMessages.find(msg => msg.id === message.id);
                            if (!exists) {
                                console.log(`üí¨ New chat message: ${message.id} by ${message.user}: "${message.text}"`);
                                this.storage.chatMessages.push(message);
                                this.storage.chatMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                                localStorage.setItem('film-spotter-chat-' + this.sessionId, JSON.stringify(this.storage.chatMessages));
                                this.refreshChat();
                            } else {
                                console.log(`üí¨ Chat message ${message.id} already exists, skipping`);
                            }
                        }
                    });
                }, (error) => {
                    console.error('‚ùå Chat listener error:', error);
                });
                
                // Listen for SESSION-LEVEL updates (playback, offset, etc.)
                const sessionUnsubscribe = sessionRef.onSnapshot((doc) => {
                    if (doc.exists) {
                        const data = doc.data();
                        
                        // Sync playback state (only if video is loaded)
                        if (data.playbackState && data.playbackState.updatedBy !== this.userName && this.video && this.video.readyState >= 2) {
                            const timeDiff = Math.abs(this.video.currentTime - data.playbackState.currentTime);
                            
                            // Always sync position when paused (critical for frame-accurate stops and nudges)
                            if (!data.playbackState.isPlaying && this.video.paused) {
                                // Both are paused - sync position even for tiny frame nudges
                                if (timeDiff > 0.001) { // Any movement at all
                                    this.video.currentTime = data.playbackState.currentTime;
                                    console.log(`üîÑ Synced POSITION at ${data.playbackState.currentTime.toFixed(3)}s from ${data.playbackState.updatedBy}`);
                                }
                            }
                            // Pause if remote is paused but we're playing
                            else if (!data.playbackState.isPlaying && !this.video.paused) {
                                const isBehind = this.video.currentTime < data.playbackState.currentTime;
                                const catchUpThreshold = 0.5; // If more than 0.5s behind, catch up first
                                
                                if (isBehind && timeDiff > catchUpThreshold) {
                                    // We're behind - keep playing to catch up
                                    console.log(`‚è© Catching up: ${timeDiff.toFixed(2)}s behind target ${data.playbackState.currentTime.toFixed(3)}s`);
                                    
                                    // Set up a check to pause when caught up
                                    const checkCatchUp = setInterval(() => {
                                        const currentDiff = data.playbackState.currentTime - this.video.currentTime;
                                        if (currentDiff <= 0.1 || this.video.currentTime >= data.playbackState.currentTime) {
                                            // Caught up! Now pause
                                            clearInterval(checkCatchUp);
                                            this.video.pause();
                                            this.video.currentTime = data.playbackState.currentTime;
                                            console.log(`‚úì Caught up and paused at ${data.playbackState.currentTime.toFixed(3)}s`);
                                        }
                                    }, 100);
                                    
                                    // Safety: force pause after 5 seconds even if not caught up
                                    setTimeout(() => {
                                        clearInterval(checkCatchUp);
                                        if (!this.video.paused) {
                                            this.video.pause();
                                            this.video.currentTime = data.playbackState.currentTime;
                                            console.log(`‚è∏ Forced pause (timeout) at ${data.playbackState.currentTime.toFixed(3)}s`);
                                        }
                                    }, 5000);
                                } else {
                                    // Close enough or ahead - pause immediately
                                    this.video.pause();
                                    this.video.currentTime = data.playbackState.currentTime;
                                    console.log(`üîÑ Synced STOP at ${data.playbackState.currentTime.toFixed(3)}s from ${data.playbackState.updatedBy}`);
                                }
                            } 
                            // Sync play state
                            else if (data.playbackState.isPlaying && this.video.paused) {
                                this.video.currentTime = data.playbackState.currentTime;
                                this.video.play().catch(e => console.log('Play blocked:', e));
                                console.log(`üîÑ Synced PLAY from ${data.playbackState.currentTime.toFixed(3)}s`);
                            }
                            // Sync seek while playing (only if difference > 0.5s to avoid jitter)
                            else if (data.playbackState.isPlaying && !this.video.paused && timeDiff > 0.5) {
                                this.video.currentTime = data.playbackState.currentTime;
                                console.log(`üîÑ Synced SEEK to ${data.playbackState.currentTime.toFixed(3)}s`);
                            }
                        }
                        
                        // Sync timecode offset
                        if (data.timecodeOffset !== undefined && data.timecodeOffset !== this.timecodeOffset) {
                            this.timecodeOffset = data.timecodeOffset;
                            
                            // Update the offset input field
                            const offsetSeconds = data.timecodeOffset;
                            const hours = Math.floor(offsetSeconds / 3600);
                            const minutes = Math.floor((offsetSeconds % 3600) / 60);
                            const seconds = Math.floor(offsetSeconds % 60);
                            const frames = Math.round((offsetSeconds % 1) * this.fps);
                            const offsetTC = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(frames).padStart(2, '0')}`;
                            
                            document.getElementById('timecodeOffset').value = offsetTC;
                            this.updateTimecode();
                            console.log('üîÑ Synced timecode offset from Firebase');
                        }
                    }
                }, (error) => {
                    console.error('‚ùå Session listener error:', error);
                });
                
                this.unsubscribeListeners.push(markersUnsubscribe, chatUnsubscribe, sessionUnsubscribe);
                
                // Listen for PARTICIPANTS changes
                const participantsUnsubscribe = sessionRef.collection('participants').onSnapshot((snapshot) => {
                    const participants = [];
                    const now = Date.now();
                    let foundMyself = false;
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        
                        // Check if this is us
                        if (data.id === this.myParticipantId) {
                            foundMyself = true;
                            // Update our own permissions
                            this.isHost = data.isHost || false;
                            this.canMark = data.canMark !== false;
                            this.canChat = data.canChat !== false;
                            this.canControl = data.canControl !== false;
                            console.log(`üîê My permissions updated: isHost=${this.isHost}, canMark=${this.canMark}, canChat=${this.canChat}`);
                        }
                        
                        // Handle lastSeen timestamp (now using client Date.now())
                        const lastSeenTime = data.lastSeen || 0;
                        
                        // If no valid timestamp, assume active (just joined)
                        if (lastSeenTime === 0) {
                            console.log(`‚úÖ ${data.name} active (just joined)`);
                            participants.push(data);
                            return;
                        }
                        
                        const timeSinceLastSeen = now - lastSeenTime;
                        
                        // 30-second window (tighter now that timestamps are reliable)
                        if (timeSinceLastSeen < 30000 && timeSinceLastSeen > -5000) {
                            participants.push(data);
                        } else {
                            console.log(`‚è∞ ${data.name} inactive: ${Math.round(timeSinceLastSeen/1000)}s ago`);
                        }
                    });
                    
                    // Check if we've been kicked (not in participant list anymore)
                    if (this.myParticipantId && !foundMyself && this.participantUpdateCount > 2) {
                        alert('You have been removed from this session by the host.');
                        // Clear heartbeat
                        if (this.participantHeartbeat) {
                            clearInterval(this.participantHeartbeat);
                        }
                        // Reload page to reset
                        setTimeout(() => location.reload(), 1000);
                        return;
                    }
                    
                    // Update participant count in header
                    const activeCount = participants.length;
                    this.participantUpdateCount++;
                    
                    // Force update first 3 times OR when count changes
                    const shouldUpdate = this.participantUpdateCount <= 3 || activeCount !== this.lastParticipantCount;
                    
                    console.log(`Checking count: current=${activeCount}, last=${this.lastParticipantCount}, update#${this.participantUpdateCount}, will${shouldUpdate ? '' : ' NOT'} update`);
                    
                    if (shouldUpdate) {
                        const text = `üë• ${activeCount} user${activeCount !== 1 ? 's' : ''}`;
                        document.getElementById('activeUsers').textContent = text;
                        this.lastParticipantCount = activeCount;
                        console.log(`üë• Updated UI to: ${text}`);
                    }
                    
                    // Always update participants panel (it's hidden unless opened)
                    this.updateParticipantsPanel(participants);
                }, (error) => {
                    console.error('‚ùå Participants listener error:', error);
                });
                
                this.unsubscribeListeners.push(participantsUnsubscribe);
            },
            
            updateParticipantsPanel(participants) {
                const panel = document.getElementById('participantsList');
                if (!panel) {
                    return;
                }
                
                if (participants.length === 0) {
                    panel.innerHTML = '<p style="color: #808080; padding: 10px;">No participants</p>';
                    return;
                }
                
                panel.innerHTML = participants.map(p => {
                    const isMe = p.id === this.myParticipantId;
                    const showControls = this.isHost && !isMe;
                    const hostBadge = p.isHost ? '<span style="background: #0066cc; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 6px;">HOST</span>' : '';
                    
                    // Button styles based on permission state
                    const markBtnStyle = p.canMark 
                        ? 'background: #0066cc; color: white;' 
                        : 'background: #555; color: #999;';
                    const chatBtnStyle = p.canChat 
                        ? 'background: #0066cc; color: white;' 
                        : 'background: #555; color: #999;';
                    const controlBtnStyle = p.canControl 
                        ? 'background: #0066cc; color: white;' 
                        : 'background: #555; color: #999;';
                    
                    return `
                        <div style="padding: 10px; background: #2d2d2d; border-radius: 4px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: #e0e0e0;">
                                        ${p.name}${isMe ? ' (You)' : ''}${hostBadge}
                                    </div>
                                    <div style="font-size: 11px; color: #808080;">
                                        ${p.canControl ? '‚úì Can control' : '‚úó No control'} ‚Ä¢ 
                                        ${p.canMark ? '‚úì Can mark' : '‚úó View only'} ‚Ä¢ 
                                        ${p.canChat ? '‚úì Can chat' : '‚úó Muted'}
                                    </div>
                                </div>
                                ${showControls ? `
                                    <div style="display: flex; gap: 4px;">
                                        <button onclick="app.makeHost('${p.id}')" style="padding: 4px 8px; font-size: 11px; background: #0066cc; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Make Host">üëë</button>
                                        <button onclick="app.togglePermission('${p.id}', 'control')" style="padding: 4px 8px; font-size: 11px; ${controlBtnStyle} border: none; border-radius: 3px; cursor: pointer;" title="Toggle Playback Control">‚èØ</button>
                                        <button onclick="app.togglePermission('${p.id}', 'mark')" style="padding: 4px 8px; font-size: 11px; ${markBtnStyle} border: none; border-radius: 3px; cursor: pointer;" title="Toggle Mark Permission">üìç</button>
                                        <button onclick="app.togglePermission('${p.id}', 'chat')" style="padding: 4px 8px; font-size: 11px; ${chatBtnStyle} border: none; border-radius: 3px; cursor: pointer;" title="Toggle Chat Permission">üí¨</button>
                                        <button onclick="app.kickUser('${p.id}')" style="padding: 4px 8px; font-size: 11px; background: #cc0000; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Kick User">‚úï</button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            },
            
            async loadSessionFromFirebase(sessionId) {
                if (!this.db) return;
                
                try {
                    const sessionRef = this.db.collection('sessions').doc(sessionId);
                    const doc = await sessionRef.get();
                    
                    if (doc.exists) {
                        const data = doc.data();
                        
                        // Check if session has video data
                        if (data.videoUrl && data.projectName) {
                            // Auto-fill the form with session data (hide URL for security)
                            document.getElementById('videoUrlInput').value = data.videoUrl;
                            document.getElementById('videoUrlInput').type = 'password'; // Hide URL from guests
                            document.getElementById('videoUrlInput').setAttribute('readonly', 'true'); // Make it readonly for guests
                            document.getElementById('projectNameInput').value = data.projectName;
                            document.getElementById('sessionNameInput').value = data.sessionName || sessionId;
                            
                            // Load timecode offset if present
                            if (data.timecodeOffset !== undefined) {
                                this.timecodeOffset = data.timecodeOffset;
                                
                                // Update the UI field
                                const hours = Math.floor(this.timecodeOffset / 3600);
                                const minutes = Math.floor((this.timecodeOffset % 3600) / 60);
                                const seconds = Math.floor(this.timecodeOffset % 60);
                                const frames = Math.round((this.timecodeOffset % 1) * this.fps);
                                const offsetTC = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(frames).padStart(2, '0')}`;
                                
                                document.getElementById('timecodeOffset').value = offsetTC;
                                
                                console.log(`‚úÖ Loaded timecode offset: ${this.timecodeOffset} (${offsetTC})`);
                            }
                            
                            // Load markers from subcollection
                            const markersSnapshot = await sessionRef.collection('markers').get();
                            if (!markersSnapshot.empty) {
                                this.storage.hitPoints = [];
                                markersSnapshot.forEach(doc => {
                                    this.storage.hitPoints.push(doc.data());
                                });
                                this.storage.hitPoints.sort((a, b) => a.time - b.time);
                                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                                console.log(`‚úÖ Loaded ${this.storage.hitPoints.length} markers from Firebase`);
                            }
                            
                            // Load chat from subcollection
                            const chatSnapshot = await sessionRef.collection('chat').get();
                            if (!chatSnapshot.empty) {
                                this.storage.chatMessages = [];
                                chatSnapshot.forEach(doc => {
                                    this.storage.chatMessages.push(doc.data());
                                });
                                this.storage.chatMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                                localStorage.setItem('film-spotter-chat-' + this.sessionId, JSON.stringify(this.storage.chatMessages));
                                console.log(`‚úÖ Loaded ${this.storage.chatMessages.length} chat messages from Firebase`);
                            }
                            
                            // Refresh displays immediately
                            await this.refreshHitPoints();
                            await this.refreshChat();
                            
                            // Update timeline markers
                            if (this.updateCustomTimelineMarkers) {
                                this.updateCustomTimelineMarkers();
                            }
                            
                            this.showMessage(`‚úì Joined session with ${this.storage.hitPoints.length} events`);
                            console.log('‚úÖ Loaded session data from Firebase');
                        } else {
                            console.log('‚ÑπÔ∏è Session exists but has no video loaded yet');
                        }
                    } else {
                        console.log('‚ÑπÔ∏è New session - no data yet');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading session from Firebase:', error);
                }
            },
            
            async saveSession(videoUrl, projectName) {
                const session = { videoUrl, projectName };
                localStorage.setItem('film-spotter-session', JSON.stringify(session));
                
                // Save to Firebase if connected
                if (this.db && this.sessionId) {
                    try {
                        const sessionName = document.getElementById('sessionNameInput').value.trim();
                        const passwordEnabled = document.getElementById('enablePassword').checked;
                        const password = passwordEnabled ? document.getElementById('sessionPassword').value : null;
                        const allowAllControl = document.getElementById('allowAllControl').checked;
                        
                        await this.db.collection('sessions').doc(this.sessionId).set({
                            videoUrl,
                            projectName,
                            sessionName: sessionName || this.sessionId,
                            password: password,
                            allowAllControl: allowAllControl,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        }, { merge: true });
                        
                        console.log('‚úÖ Session metadata saved to Firebase' + (password ? ' (password protected)' : ''));
                    } catch (error) {
                        console.error('‚ùå Error saving session to Firebase:', error);
                    }
                }
            },
            
            async loadVideo() {
                try {
                    const videoUrl = document.getElementById('videoUrlInput').value.trim();
                    const projectName = document.getElementById('projectNameInput').value.trim();
                    const userName = document.getElementById('userNameInput').value.trim();
                    const sessionName = document.getElementById('sessionNameInput').value.trim();
                    
                    console.log('üé¨ Loading video...', { videoUrl, projectName, userName, sessionName });
                    
                    if (userName) {
                        this.userName = userName;
                        localStorage.setItem('film-spotter-username', userName);
                        document.getElementById('userBadge').textContent = userName;
                    }
                    
                    // Store session name (friendly display name)
                    // But keep the existing random session ID
                    if (sessionName) {
                        console.log(`üìù Session name: "${sessionName}" (ID: ${this.sessionId})`);
                        this.sessionName = sessionName;
                        this.saveSessionToRecents(this.sessionId, sessionName);
                    }
                    
                    // Update header with session name only
                    const displayText = sessionName || this.sessionId;
                    document.getElementById('sessionNameDisplay').textContent = displayText;
                    console.log(`üìå Active session: ${this.sessionId}`);
                    
                    if (!videoUrl) {
                        alert('Please enter a video URL');
                        return;
                    }
                
                // Convert various video URL formats
                let finalUrl = videoUrl;
                let useIframe = false;
                
                // Handle Dropbox URLs - convert to raw content URL
                if (videoUrl.includes('dropbox.com')) {
                    finalUrl = videoUrl.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
                    if (finalUrl.includes('dl=0')) {
                        finalUrl = finalUrl.replace('dl=0', 'dl=1');
                    } else if (!finalUrl.includes('dl=1')) {
                        finalUrl += (finalUrl.includes('?') ? '&' : '?') + 'dl=1';
                    }
                    if (!finalUrl.includes('raw=1')) {
                        finalUrl += '&raw=1';
                    }
                    console.log('Converted Dropbox URL to:', finalUrl);
                }
                
                // Handle Vimeo URLs
                if (videoUrl.includes('vimeo.com')) {
                    if (!videoUrl.includes('player.vimeo.com')) {
                        const vimeoId = videoUrl.split('/').filter(part => part.match(/^\d+$/))[0];
                        if (vimeoId) {
                            finalUrl = `https://player.vimeo.com/video/${vimeoId}`;
                        }
                    }
                    useIframe = true;
                }
                
                // Handle Google Drive URLs
                if (videoUrl.includes('drive.google.com')) {
                    let fileId = '';
                    if (videoUrl.includes('/file/d/')) {
                        fileId = videoUrl.split('/file/d/')[1].split('/')[0];
                    } else if (videoUrl.includes('id=')) {
                        fileId = videoUrl.split('id=')[1].split('&')[0];
                    }
                    
                    if (fileId) {
                        finalUrl = `https://drive.google.com/file/d/${fileId}/preview`;
                        useIframe = true;
                    } else {
                        alert('Could not extract Google Drive file ID. Please make sure the file is shared with "Anyone with the link"');
                        return;
                    }
                }
                
                const videoContainer = document.querySelector('.video-container');
                
                // For iframe-based videos (Vimeo, Google Drive)
                if (useIframe || videoUrl.includes('iframe') || videoUrl.includes('player.vimeo.com') || videoUrl.includes('preview')) {
                    videoContainer.innerHTML = `<iframe id="videoFrame" src="${finalUrl}" width="100%" height="500" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe><div class="timeline-markers" id="timelineMarkers"></div>`;
                    alert('Video loaded! Note: Vimeo and Google Drive videos have limited controls. Frame-by-frame navigation may not work. For full features, use a Dropbox link.');
                } else {
                    // Direct video file
                    this.video.src = finalUrl;
                    
                    // Additional download protection
                    this.video.controlsList = "nodownload";
                    this.video.disablePictureInPicture = true;
                    
                    this.video.load();
                    
                    this.video.addEventListener('loadeddata', () => {
                        console.log('Video loaded successfully');
                        this.showMessage('‚úì Video loaded successfully! You can now use frame-by-frame controls.');
                        this.showVideoMetadata();
                        
                        // Update timeline markers after video loads
                        if (this.updateCustomTimelineMarkers) {
                            this.updateCustomTimelineMarkers();
                        }
                    }, { once: true });
                    
                    this.video.addEventListener('error', (e) => {
                        this.showMessage('Error loading video. Trying alternative format...', true);
                        console.error('Video error:', e);
                        
                        if (videoUrl.includes('dropbox.com')) {
                            const alternativeUrl = videoUrl.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('dl=0', 'raw=1');
                            console.log('Trying alternative URL:', alternativeUrl);
                            this.video.src = alternativeUrl;
                            this.video.controlsList = "nodownload";
                            this.video.disablePictureInPicture = true;
                            this.video.load();
                        }
                    }, { once: true });
                }
                
                document.getElementById('videoSetup').classList.add('hidden');
                document.getElementById('videoPlayer').classList.remove('hidden');
                document.querySelector('.sidebar').style.display = 'flex';
                document.getElementById('sessionControls').classList.remove('hidden');
                document.getElementById('headerInfo').classList.remove('hidden');
                
                // Setup custom timeline NOW that elements are visible
                console.log('üé¨ Setting up custom timeline...');
                this.setupCustomTimeline();
                
                // Refresh events and chat display after video loads (important for guests)
                await this.refreshHitPoints();
                await this.refreshChat();
                
                // Register this user as a participant
                await this.registerParticipant();
                
                await this.saveSession(videoUrl, projectName);
                } catch (error) {
                    console.error('‚ùå Error loading video:', error);
                    alert(`Error loading video: ${error.message}`);
                }
            },
            
            async registerParticipant() {
                if (!this.db || !this.sessionId || !this.userName) return;
                
                // Use consistent ID based on username (not timestamp)
                const participantId = `user-${this.userName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                this.myParticipantId = participantId;
                
                try {
                    const now = Date.now();
                    
                    // Check if this is the first participant (they become host)
                    const participantsSnapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').get();
                    
                    const isFirstParticipant = participantsSnapshot.empty;
                    
                    // Check session settings for allowAllControl
                    const sessionDoc = await this.db.collection('sessions').doc(this.sessionId).get();
                    const allowAllControl = sessionDoc.exists ? sessionDoc.data().allowAllControl : false;
                    
                    // Host always gets all permissions
                    // Guests get permissions based on allowAllControl setting
                    const permissions = isFirstParticipant ? {
                        canMark: true,
                        canChat: true,
                        canControl: true
                    } : {
                        canMark: allowAllControl,
                        canChat: allowAllControl,
                        canControl: allowAllControl
                    };
                    
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(participantId).set({
                            id: participantId,
                            name: this.userName,
                            joinedAt: now,
                            lastSeen: now,
                            isHost: isFirstParticipant,
                            ...permissions
                        }, { merge: true });
                    
                    // Store our role locally
                    this.isHost = isFirstParticipant;
                    this.canMark = permissions.canMark;
                    this.canChat = permissions.canChat;
                    this.canControl = permissions.canControl;
                    
                    console.log(`‚úÖ Registered as participant: ${this.userName} (${participantId}) - Host: ${isFirstParticipant}, Permissions:`, permissions);
                    
                    // Clear any existing heartbeat
                    if (this.participantHeartbeat) {
                        clearInterval(this.participantHeartbeat);
                    }
                    // Update lastSeen every 10 seconds to show active status
                    this.participantHeartbeat = setInterval(async () => {
                        try {
                            await this.db.collection('sessions').doc(this.sessionId)
                                .collection('participants').doc(participantId).update({
                                    lastSeen: Date.now()
                                });
                            console.log(`üíì Heartbeat sent for ${this.userName}`);
                        } catch (error) {
                            console.error('‚ùå Heartbeat error:', error);
                        }
                    }, 10000);
                    
                    // Immediately refresh participants display
                    await this.refreshParticipants();
                    
                    console.log(`‚úÖ Registered as participant: ${this.userName} (${participantId})`);
                } catch (error) {
                    console.error('‚ùå Error registering participant:', error);
                }
            },
            
            async refreshParticipants() {
                if (!this.db || !this.sessionId) return;
                
                try {
                    const snapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').get();
                    
                    const participants = [];
                    const now = Date.now();
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const lastSeenTime = data.lastSeen || 0;
                        
                        // If no valid timestamp or within 30 seconds, consider active
                        if (lastSeenTime === 0 || (now - lastSeenTime < 30000 && now - lastSeenTime > -5000)) {
                            participants.push(data);
                        }
                    });
                    
                    this.renderParticipants(participants);
                    console.log(`üë• Refreshed participants: ${participants.length} active`);
                } catch (error) {
                    console.error('‚ùå Error refreshing participants:', error);
                }
            },
            
            updateFPS() {
                this.fps = parseFloat(document.getElementById('fpsSelect').value);
                this.updateTimecode();
            },
            
            async detectFrameRate() {
                // Try to detect frame rate by measuring frame intervals
                const video = this.video;
                if (!video || video.readyState < 2) return;
                
                return new Promise((resolve) => {
                    let frameTimes = [];
                    let frameCount = 0;
                    const maxSamples = 30;
                    
                    const measureFrame = () => {
                        if (frameCount >= maxSamples) {
                            // Calculate average frame interval
                            const intervals = [];
                            for (let i = 1; i < frameTimes.length; i++) {
                                intervals.push(frameTimes[i] - frameTimes[i-1]);
                            }
                            const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                            const detectedFPS = 1000 / avgInterval;
                            
                            // Round to common frame rates
                            const commonFPS = [23.976, 24, 25, 29.97, 30, 50, 60];
                            let closestFPS = commonFPS[0];
                            let minDiff = Math.abs(detectedFPS - closestFPS);
                            
                            for (let fps of commonFPS) {
                                const diff = Math.abs(detectedFPS - fps);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    closestFPS = fps;
                                }
                            }
                            
                            this.detectedFPS = closestFPS;
                            this.fps = closestFPS;
                            
                            // Update UI
                            document.getElementById('fpsSelect').value = closestFPS;
                            document.getElementById('metaFrameRate').textContent = 
                                `Detected Frame Rate: ${closestFPS} fps (auto-detected)`;
                            
                            console.log('Detected frame rate:', closestFPS);
                            video.pause();
                            video.currentTime = 0;
                            resolve(closestFPS);
                            return;
                        }
                        
                        frameTimes.push(performance.now());
                        frameCount++;
                        requestAnimationFrame(measureFrame);
                    };
                    
                    // Start playback to measure frames
                    video.currentTime = 1; // Skip to 1 second to avoid any intro issues
                    video.play();
                    requestAnimationFrame(measureFrame);
                    
                    // Timeout after 3 seconds
                    setTimeout(() => {
                        video.pause();
                        video.currentTime = 0;
                        resolve(30); // Default to 30
                    }, 3000);
                });
            },
            
            showVideoMetadata() {
                const video = this.video;
                const metadata = document.getElementById('videoMetadata');
                
                if (video.videoWidth && video.videoHeight) {
                    document.getElementById('metaResolution').textContent = 
                        `Resolution: ${video.videoWidth} √ó ${video.videoHeight}`;
                }
                
                if (video.duration) {
                    const duration = video.duration;
                    const hours = Math.floor(duration / 3600);
                    const minutes = Math.floor((duration % 3600) / 60);
                    const seconds = Math.floor(duration % 60);
                    document.getElementById('metaDuration').textContent = 
                        `Duration: ${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
                
                // Try to get codec info from video element
                const codecElement = document.getElementById('metaCodec');
                const colorSpaceElement = document.getElementById('metaColorSpace');
                
                // HTML5 video has limited metadata exposure
                try {
                    // Check if video has source with type attribute
                    const source = video.querySelector('source');
                    if (source && source.type) {
                        codecElement.textContent = `Codec: ${source.type}`;
                    } else if (video.src) {
                        // Infer from file extension
                        const ext = video.src.split('.').pop().split('?')[0].toLowerCase();
                        const codecMap = {
                            'mp4': 'H.264 / AAC',
                            'webm': 'VP8 / VP9',
                            'mov': 'ProRes / H.264',
                            'mxf': 'DNxHD / ProRes'
                        };
                        codecElement.textContent = `Codec: ${codecMap[ext] || 'Unknown'}`;
                    } else {
                        codecElement.textContent = 'Codec: Unknown';
                    }
                } catch (e) {
                    codecElement.textContent = 'Codec: Unknown';
                }
                
                // Try to get color space from video color metadata
                try {
                    // Modern browsers expose videoColorSpace on some video elements
                    if (video.videoWidth && video.videoHeight) {
                        // Check for VideoColorSpace API (newer Chrome/Edge)
                        if (typeof VideoColorSpace !== 'undefined' && video.getVideoPlaybackQuality) {
                            // Attempt to access color space info
                            const tracks = video.videoTracks;
                            if (tracks && tracks.length > 0) {
                                colorSpaceElement.textContent = 'Color Space: Available in video metadata';
                            } else {
                                // Most common defaults based on resolution
                                const isHD = video.videoHeight >= 720;
                                const is4K = video.videoHeight >= 2160;
                                
                                if (is4K) {
                                    colorSpaceElement.textContent = 'Color Space: Likely Rec.2020 or Rec.709 (4K)';
                                } else if (isHD) {
                                    colorSpaceElement.textContent = 'Color Space: Likely Rec.709 (HD)';
                                } else {
                                    colorSpaceElement.textContent = 'Color Space: Likely Rec.601 (SD)';
                                }
                            }
                        } else {
                            // Fallback: infer from resolution
                            const isHD = video.videoHeight >= 720;
                            const is4K = video.videoHeight >= 2160;
                            
                            if (is4K) {
                                colorSpaceElement.textContent = 'Color Space: Inferred Rec.2020/709 (4K)';
                            } else if (isHD) {
                                colorSpaceElement.textContent = 'Color Space: Inferred Rec.709 (HD)';
                            } else {
                                colorSpaceElement.textContent = 'Color Space: Inferred Rec.601 (SD)';
                            }
                        }
                    } else {
                        colorSpaceElement.textContent = 'Color Space: Not available';
                    }
                } catch (e) {
                    colorSpaceElement.textContent = 'Color Space: Browser does not expose this data';
                }
                
                metadata.style.display = 'block';
            },
            
            toggleMetadata() {
                const content = document.getElementById('metadataContent');
                const icon = document.getElementById('metadataToggleIcon');
                
                if (content.classList.contains('hidden')) {
                    content.classList.remove('hidden');
                    icon.textContent = '‚ñº';
                } else {
                    content.classList.add('hidden');
                    icon.textContent = '‚ñ∂';
                }
            },
            
            togglePlayPause() {
                if (!this.canControl) {
                    this.showMessage('‚õî You do not have permission to control playback', true);
                    return;
                }
                if (this.video.paused) {
                    this.video.play();
                } else {
                    this.video.pause();
                }
                // Sync playback state to Firebase
                this.syncPlaybackState();
            },
            
            skipBack() {
                if (!this.canControl) {
                    this.showMessage('‚õî You do not have permission to control playback', true);
                    return;
                }
                this.video.currentTime = Math.max(0, this.video.currentTime - 5);
                this.syncPlaybackState();
            },
            
            skipForward() {
                if (!this.canControl) {
                    this.showMessage('‚õî You do not have permission to control playback', true);
                    return;
                }
                this.video.currentTime = Math.min(this.video.duration, this.video.currentTime + 5);
                this.syncPlaybackState();
            },
            
            setVolume(value) {
                this.video.volume = value / 100;
            },
            
            toggleFullscreen() {
                const videoContainer = document.querySelector('.video-container');
                if (!document.fullscreenElement) {
                    videoContainer.requestFullscreen().catch(err => {
                        console.error('Error attempting fullscreen:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            },
            
            previousFrame() {
                if (!this.canControl) {
                    this.showMessage('‚õî You do not have permission to control playback', true);
                    return;
                }
                console.log('‚èÆÔ∏è Previous frame');
                this.video.pause();
                const frameDuration = 1 / this.fps;
                this.video.currentTime = Math.max(0, this.video.currentTime - frameDuration);
                console.log(`   New time: ${this.video.currentTime.toFixed(3)}s`);
                this.syncPlaybackState();
            },
            
            nextFrame() {
                if (!this.canControl) {
                    this.showMessage('‚õî You do not have permission to control playback', true);
                    return;
                }
                console.log('‚è≠Ô∏è Next frame');
                this.video.pause();
                const frameDuration = 1 / this.fps;
                this.video.currentTime = Math.min(this.video.duration, this.video.currentTime + frameDuration);
                console.log(`   New time: ${this.video.currentTime.toFixed(3)}s`);
                this.syncPlaybackState();
            },
            
            async syncPlaybackState() {
                if (!this.db || !this.sessionId) return;
                
                try {
                    await this.db.collection('sessions').doc(this.sessionId).set({
                        playbackState: {
                            isPlaying: !this.video.paused,
                            currentTime: this.video.currentTime,
                            updatedBy: this.userName,
                            timestamp: Date.now()
                        }
                    }, { merge: true });
                } catch (error) {
                    console.error('‚ùå Error syncing playback:', error);
                }
            },
            
            async syncOffsetToFirebase() {
                if (!this.db || !this.sessionId) return;
                
                try {
                    await this.db.collection('sessions').doc(this.sessionId).set({
                        timecodeOffset: this.timecodeOffset
                    }, { merge: true });
                    console.log('‚úÖ Timecode offset synced to Firebase');
                } catch (error) {
                    console.error('‚ùå Error syncing offset:', error);
                }
            },
            
            updateTimecode() {
                let time = Math.max(0, this.video.currentTime + this.timecodeOffset); // Prevent negative time
                
                if (this.useDropFrame && (this.fps === 29.97 || this.fps === 59.94)) {
                    // Drop-frame timecode calculation for 29.97 or 59.94
                    // Drop 2 frames every minute except every 10th minute
                    const dropFrames = this.fps === 59.94 ? 4 : 2;
                    const framesPerHour = Math.round(this.fps * 3600);
                    const framesPer24Hours = framesPerHour * 24;
                    const framesPer10Minutes = Math.round(this.fps * 600);
                    const framesPerMinute = Math.round(this.fps * 60) - dropFrames;
                    
                    let totalFrames = Math.round(time * this.fps);
                    
                    // Calculate drop-frame timecode
                    const d = Math.floor(totalFrames / framesPer10Minutes);
                    const m = totalFrames % framesPer10Minutes;
                    
                    if (m > dropFrames) {
                        totalFrames += dropFrames * 9 * d + dropFrames * Math.floor((m - dropFrames) / framesPerMinute);
                    } else {
                        totalFrames += dropFrames * 9 * d;
                    }
                    
                    const fps = Math.round(this.fps);
                    const frames = totalFrames % fps;
                    const seconds = Math.floor(totalFrames / fps) % 60;
                    const minutes = Math.floor(totalFrames / (fps * 60)) % 60;
                    const hours = Math.floor(totalFrames / (fps * 3600));
                    
                    // Use semicolons for drop-frame
                    const timecode = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')};${String(frames).padStart(2, '0')}`;
                    document.getElementById('timecode').textContent = timecode;
                } else {
                    // Non-drop-frame timecode
                    const hours = Math.floor(time / 3600);
                    const minutes = Math.floor((time % 3600) / 60);
                    const seconds = Math.floor(time % 60);
                    const frames = Math.min(Math.floor(this.fps) - 1, Math.round((time % 1) * this.fps));
                    
                    const timecode = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(frames).padStart(2, '0')}`;
                    document.getElementById('timecode').textContent = timecode;
                }
            },
            
            toggleDropFrame() {
                this.useDropFrame = document.getElementById('dropFrame').checked;
                this.updateTimecode();
                
                if (this.useDropFrame) {
                    if (this.fps !== 29.97 && this.fps !== 59.94) {
                        this.showMessage('‚ö†Ô∏è Drop-frame is typically only used with 29.97 or 59.94 fps', false);
                    } else {
                        this.showMessage('‚úì Drop-frame timecode enabled');
                    }
                } else {
                    this.showMessage('‚úì Non-drop-frame timecode');
                }
            },
            
            updateMarkerTypes() {
                const deptSelect = document.getElementById('departmentSelect');
                const markerSelect = document.getElementById('markerType');
                const musicMetadata = document.getElementById('musicMetadata');
                const selectedDept = deptSelect.value;
                
                // Show/hide music metadata based on department
                if (selectedDept === 'music') {
                    musicMetadata.classList.remove('hidden');
                } else {
                    musicMetadata.classList.add('hidden');
                }
                
                // Clear and repopulate marker dropdown
                markerSelect.innerHTML = '';
                
                if (selectedDept === 'global') {
                    // Show ALL markers from ALL departments in alphabetical order
                    this.currentDepartment = 'music'; // Default to music for saving
                    
                    const allMarkers = [];
                    Object.keys(this.departments).forEach(deptKey => {
                        this.departments[deptKey].markers.forEach(marker => {
                            // Avoid duplicates
                            if (!allMarkers.find(m => m.value === marker.value)) {
                                allMarkers.push(marker);
                            }
                        });
                    });
                    
                    // Sort alphabetically
                    allMarkers.sort((a, b) => a.label.localeCompare(b.label));
                    
                    allMarkers.forEach(marker => {
                        const option = document.createElement('option');
                        option.value = marker.value;
                        option.textContent = marker.label;
                        markerSelect.appendChild(option);
                    });
                } else {
                    // Show markers for selected department
                    this.currentDepartment = selectedDept;
                    const markers = this.departments[selectedDept].markers;
                    
                    markers.forEach(marker => {
                        const option = document.createElement('option');
                        option.value = marker.value;
                        option.textContent = marker.label;
                        markerSelect.appendChild(option);
                    });
                }
            },
            
            handleDepartmentFilter(clicked) {
                const globalCheck = document.getElementById('filter-global');
                const musicCheck = document.getElementById('filter-music');
                const soundCheck = document.getElementById('filter-sound');
                const vfxCheck = document.getElementById('filter-vfx');
                const editCheck = document.getElementById('filter-edit');
                const colorCheck = document.getElementById('filter-color');
                
                // If Global was clicked and is now checked, uncheck all others
                if (clicked === 'global' && globalCheck.checked) {
                    musicCheck.checked = false;
                    soundCheck.checked = false;
                    vfxCheck.checked = false;
                    editCheck.checked = false;
                    colorCheck.checked = false;
                    this.activeFilters = ['global'];
                } else {
                    // Build active filters array from checked boxes
                    this.activeFilters = [];
                    
                    if (musicCheck.checked) this.activeFilters.push('music');
                    if (soundCheck.checked) this.activeFilters.push('sound');
                    if (vfxCheck.checked) this.activeFilters.push('vfx');
                    if (editCheck.checked) this.activeFilters.push('edit');
                    if (colorCheck.checked) this.activeFilters.push('color');
                    
                    // If any specific department is checked, uncheck Global
                    if (this.activeFilters.length > 0) {
                        globalCheck.checked = false;
                    } else {
                        // If nothing is checked, default to Global
                        globalCheck.checked = true;
                        this.activeFilters = ['global'];
                    }
                }
                
                console.log('Active filters:', this.activeFilters);
                this.refreshHitPoints();
            },
            
            updateTimecodeOffset() {
                const input = document.getElementById('timecodeOffset').value.trim();
                if (!input) {
                    this.timecodeOffset = 0;
                    this.updateTimecode();
                    this.recalculateEventTimecodes();
                    this.syncOffsetToFirebase();
                    return;
                }
                
                // Parse timecode format HH:MM:SS:FF
                const parts = input.split(':');
                if (parts.length === 4) {
                    const hours = parseInt(parts[0]) || 0;
                    const minutes = parseInt(parts[1]) || 0;
                    const seconds = parseInt(parts[2]) || 0;
                    const frames = parseInt(parts[3]) || 0;
                    
                    // Calculate offset in seconds with precise frame calculation
                    this.timecodeOffset = hours * 3600 + minutes * 60 + seconds + (frames / this.fps);
                    
                    // Save to localStorage
                    localStorage.setItem('film-spotter-offset-' + this.sessionId, this.timecodeOffset.toString());
                    
                    this.updateTimecode();
                    this.recalculateEventTimecodes();
                    this.syncOffsetToFirebase();
                    
                    // Show what we actually set it to
                    const verifyTime = this.timecodeOffset;
                    const vHours = Math.floor(verifyTime / 3600);
                    const vMinutes = Math.floor((verifyTime % 3600) / 60);
                    const vSeconds = Math.floor(verifyTime % 60);
                    const vFrames = Math.round((verifyTime % 1) * this.fps);
                    const verifyTC = `${String(vHours).padStart(2, '0')}:${String(vMinutes).padStart(2, '0')}:${String(vSeconds).padStart(2, '0')}:${String(vFrames).padStart(2, '0')}`;
                    
                    this.showMessage('‚úì Timecode offset updated - event timecodes recalculated');
                } else {
                    alert('Invalid timecode format. Use HH:MM:SS:FF (e.g., 01:26:18:10)');
                }
            },
            
            recalculateEventTimecodes() {
                // Recalculate timecodes for all events that haven't been manually edited
                let updatedCount = 0;
                this.storage.hitPoints.forEach(hp => {
                    if (!hp.manuallyEditedTimecode) {
                        // Recalculate timecode from video time + offset
                        const totalSeconds = hp.time + this.timecodeOffset;
                        const hours = Math.floor(totalSeconds / 3600);
                        const minutes = Math.floor((totalSeconds % 3600) / 60);
                        const seconds = Math.floor(totalSeconds % 60);
                        const frames = Math.round((totalSeconds % 1) * this.fps);
                        
                        const separator = this.useDropFrame ? ';' : ':';
                        hp.timecode = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}${separator}${String(frames).padStart(2, '0')}`;
                        updatedCount++;
                    }
                });
                
                if (updatedCount > 0) {
                    this.saveStoredData();
                    this.refreshHitPoints();
                }
            },
            
            toggleFollowEvents() {
                this.followEvents = document.getElementById('followEvents').checked;
                if (this.followEvents) {
                    this.showMessage('üìç Following events - will auto-scroll');
                } else {
                    this.showMessage('Follow events disabled');
                }
            },
            
            highlightCurrentEvent() {
                // Throttle updates to every 100ms to prevent flashing
                const now = Date.now();
                if (now - this.lastHighlightUpdate < 100) {
                    return;
                }
                this.lastHighlightUpdate = now;
                
                const currentTime = this.video.currentTime;
                
                // Find the current event (the most recent one we've passed)
                let currentEvent = null;
                let nextEvent = null;
                
                // Sort events by time
                const sortedEvents = [...this.storage.hitPoints].sort((a, b) => a.time - b.time);
                
                // Find the LAST event we've passed (or are very close to)
                for (let i = sortedEvents.length - 1; i >= 0; i--) {
                    // We've passed this event (with 0.2s tolerance for timing jitter)
                    if (currentTime >= sortedEvents[i].time - 0.2) {
                        currentEvent = sortedEvents[i];
                        nextEvent = sortedEvents[i + 1] || null;
                        break;
                    }
                }
                
                // Only update if the highlighted event has changed
                const newHighlightId = currentEvent ? currentEvent.id : null;
                const highlightChanged = this.currentHighlightedEventId !== newHighlightId;
                
                if (highlightChanged) {
                    console.log(`üí° Highlight changed: ${this.currentHighlightedEventId} ‚Üí ${newHighlightId}`);
                }
                
                // Update highlights
                const eventElements = document.querySelectorAll('.hit-point');
                eventElements.forEach(el => {
                    const timecodeSpan = el.querySelector('.timecode-editable');
                    if (!timecodeSpan) return;
                    
                    const isCurrentEvent = currentEvent && timecodeSpan.textContent === currentEvent.timecode;
                    const currentBg = el.style.backgroundColor;
                    
                    if (isCurrentEvent) {
                        // This is the current event
                        if (highlightChanged) {
                            // JUST became current - fade in
                            el.style.transition = 'background-color 0.8s ease-in';
                            el.style.backgroundColor = 'rgba(0, 102, 204, 0.15)';
                            console.log(`‚ú® Fading IN: ${timecodeSpan.textContent} (was: ${currentBg})`);
                        } else {
                            // Already current - keep it lit (no transition to avoid flashing)
                            el.style.transition = 'none';
                            el.style.backgroundColor = 'rgba(0, 102, 204, 0.15)';
                            // Only log if background was somehow wrong
                            if (!currentBg || !currentBg.includes('102, 204')) {
                                console.log(`üîß Maintaining highlight: ${timecodeSpan.textContent} (was: ${currentBg})`);
                            }
                        }
                    } else {
                        // Not current
                        if (currentBg && currentBg.includes('102, 204')) {
                            // Was highlighted, now fade to black (match list background)
                            el.style.transition = 'background-color 1.5s ease-out';
                            el.style.backgroundColor = '#1a1a1a'; // Dark background to match
                            if (highlightChanged) {
                                console.log(`üí® Fading OUT: ${timecodeSpan.textContent} to black`);
                            }
                        }
                    }
                });
                
                // Update tracked highlighted event
                this.currentHighlightedEventId = newHighlightId;
                
                // Auto-scroll to current event if Follow Events is enabled
                if (this.followEvents && highlightChanged && currentEvent) {
                    console.log(`üìç Follow Events: Looking for ${currentEvent.timecode}`);
                    const currentElement = Array.from(eventElements).find(el => {
                        const timecodeSpan = el.querySelector('.timecode-editable');
                        return timecodeSpan && timecodeSpan.textContent === currentEvent.timecode;
                    });
                    
                    if (currentElement) {
                        // Get the ACTUAL scrollable container (tab-content parent, not hitPointsList)
                        const container = document.getElementById('hitpointsTab');
                        if (container) {
                            // Calculate position to scroll to (center the element)
                            const elementTop = currentElement.offsetTop;
                            const containerHeight = container.clientHeight;
                            const elementHeight = currentElement.clientHeight;
                            
                            // Add offset to account for filters/follow events header (~150px)
                            const headerOffset = 150;
                            const scrollPosition = elementTop - (containerHeight / 2) + (elementHeight / 2) - headerOffset;
                            
                            console.log(`üìç Scrolling to ${currentEvent.timecode}: offset=${elementTop}, scrollTo=${scrollPosition}`);
                            
                            container.scrollTo({
                                top: scrollPosition,
                                behavior: 'smooth'
                            });
                        } else {
                            console.log(`‚ö†Ô∏è Container 'hitpointsTab' not found`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è Element not found for ${currentEvent.timecode}`);
                    }
                } else {
                    if (highlightChanged && currentEvent) {
                        console.log(`üìç Follow Events disabled (followEvents=${this.followEvents})`);
                    }
                }
            },
            
            updateTimelineMarkers() {
                const duration = this.video.duration;
                if (!duration) return;
                
                const markersContainer = document.getElementById('timelineMarkers');
                if (!markersContainer) return;
                
                markersContainer.innerHTML = '';
                
                // Filter markers by active filters
                let filteredPoints = this.storage.hitPoints;
                if (!this.activeFilters.includes('global')) {
                    filteredPoints = this.storage.hitPoints.filter(hp => 
                        this.activeFilters.includes(hp.department || 'music')
                    );
                }
                
                filteredPoints.forEach(hp => {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    const position = (hp.time / duration) * 100;
                    
                    // Get color from stored marker or department config
                    const color = hp.color || '#ffcc00';
                    
                    // Set position and styling
                    marker.style.left = position + '%';
                    marker.style.background = color;
                    marker.setAttribute('style', marker.getAttribute('style') + '; width: 3px !important; min-width: 3px !important; max-width: 3px !important;');
                    
                    // Get label from department config
                    const dept = hp.department || 'music';
                    const deptConfig = this.departments[dept];
                    const markerConfig = deptConfig.markers.find(m => m.value === hp.type);
                    const label = markerConfig ? markerConfig.label : hp.type;
                    
                    marker.title = `${label}: ${hp.timecode} - ${hp.note}`;
                    marker.onclick = () => this.jumpToHitPoint(hp.time);
                    markersContainer.appendChild(marker);
                });
            },
            
            showMessage(text, isError = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = isError ? 'error-message' : 'success-message';
                messageDiv.textContent = text;
                document.body.appendChild(messageDiv);
                
                setTimeout(() => {
                    messageDiv.remove();
                }, 3000);
            },
            
            async markHitPoint() {
                // Check permission
                if (!this.canMark) {
                    this.showMessage('‚õî You do not have permission to mark events', true);
                    return;
                }
                
                const note = document.getElementById('hitPointNote').value.trim();
                const time = this.video.currentTime;
                const markerType = document.getElementById('markerType').value;
                const deptSelect = document.getElementById('departmentSelect').value;
                
                // Determine actual department (if Global, determine from marker type)
                let department = this.currentDepartment;
                if (deptSelect === 'global') {
                    // Find which department this marker belongs to
                    for (let deptKey in this.departments) {
                        if (this.departments[deptKey].markers.find(m => m.value === markerType)) {
                            department = deptKey;
                            break;
                        }
                    }
                }
                
                if (!time && time !== 0) {
                    this.showMessage('Please load a video first', true);
                    return;
                }
                
                // Get marker color from department config
                const deptConfig = this.departments[department];
                const markerConfig = deptConfig.markers.find(m => m.value === markerType);
                const markerColor = markerConfig ? markerConfig.color : deptConfig.color;
                
                const hitPoint = {
                    id: `${this.userName}-${Date.now()}`, // Unique ID with username
                    time: time,
                    timecode: document.getElementById('timecode').textContent,
                    note: note || 'Unmarked marker',
                    timestamp: new Date().toISOString(),
                    user: this.userName,
                    type: markerType,
                    department: department,
                    color: markerColor,
                    manuallyEditedTimecode: false // Track if user manually edited timecode
                };
                
                // Add music metadata if applicable
                if (department === 'music') {
                    const categoryChecked = document.querySelector('input[name="category"]:checked');
                    const usageChecked = document.querySelector('input[name="usage"]:checked');
                    hitPoint.category = categoryChecked ? categoryChecked.value : null;
                    hitPoint.usage = usageChecked ? usageChecked.value : null;
                }
                
                console.log('Marking hit point:', hitPoint);
                
                this.storage.hitPoints.push(hitPoint);
                this.storage.hitPoints.sort((a, b) => a.time - b.time);
                
                // Save to Firebase IMMEDIATELY as individual document
                try {
                    await this.saveMarkerToFirebase(hitPoint);
                } catch (error) {
                    // Error already shown by saveMarkerToFirebase
                    console.error('Failed to save to Firebase, but saved locally');
                }
                
                // Also save to localStorage as backup
                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                
                const markerLabel = markerConfig ? markerConfig.label : markerType;
                this.showMessage(`‚úì ${markerLabel} marked at ` + hitPoint.timecode);
                
                // Clear inputs
                document.getElementById('hitPointNote').value = '';
                if (department === 'music') {
                    document.querySelectorAll('input[name="category"]').forEach(cb => cb.checked = false);
                    document.querySelectorAll('input[name="usage"]').forEach(cb => cb.checked = false);
                }
                
                await this.refreshHitPoints();
            },
            
            async refreshHitPoints() {
                const listElement = document.getElementById('hitPointsList');
                const emptyElement = document.getElementById('emptyHitPoints');
                
                // Filter hit points by active filters
                let filteredPoints = this.storage.hitPoints;
                if (!this.activeFilters.includes('global')) {
                    filteredPoints = this.storage.hitPoints.filter(hp => 
                        this.activeFilters.includes(hp.department || 'music')
                    );
                }
                
                if (filteredPoints.length === 0) {
                    listElement.innerHTML = '';
                    emptyElement.classList.remove('hidden');
                } else {
                    emptyElement.classList.add('hidden');
                    listElement.innerHTML = filteredPoints.map(hp => {
                        // Get label and color from department config
                        const dept = hp.department || 'music';
                        const deptConfig = this.departments[dept];
                        const markerConfig = deptConfig.markers.find(m => m.value === hp.type);
                        const label = markerConfig ? markerConfig.label : hp.type;
                        const color = hp.color || (markerConfig ? markerConfig.color : deptConfig.color);
                        
                        // Short label for display
                        let shortLabel = label;
                        if (label === 'Music In') shortLabel = 'M-IN';
                        else if (label === 'Music Out') shortLabel = 'M-OUT';
                        else if (label === 'Song In') shortLabel = 'S-IN';
                        else if (label === 'Song Out') shortLabel = 'S-OUT';
                        else if (label === 'Audio Reference') shortLabel = 'AREF';
                        else if (label === 'Hit Point') shortLabel = '‚Ä¢';
                        else if (label === 'Backgrounds') shortLabel = 'BG';
                        else if (label === 'Clean Up') shortLabel = 'CLNP';
                        
                        // Category/Usage abbreviations for music department
                        let metadataTag = '';
                        if (dept === 'music' && (hp.category || hp.usage)) {
                            const catAbbr = hp.category === 'source' ? 'S' : hp.category === 'underscore' ? 'U' : '';
                            const useAbbr = hp.usage === 'bg-inst' ? 'BI' : 
                                           hp.usage === 'bg-vocal' ? 'BV' : 
                                           hp.usage === 'vis-inst' ? 'VI' : 
                                           hp.usage === 'vis-vocal' ? 'VV' : '';
                            
                            const parts = [];
                            if (catAbbr) parts.push(catAbbr);
                            if (useAbbr) parts.push(useAbbr);
                            
                            if (parts.length > 0) {
                                metadataTag = ` <span style="font-size: 10px; color: #808080;">- ${parts.join('/')}</span>`;
                            }
                        }
                        
                        return `
                            <div class="hit-point" style="border-left-color: ${color};">
                                <div class="hit-point-header">
                                    <span class="hit-point-time" style="color: ${color};">
                                        <span class="marker-label" style="background: ${color}33;">${shortLabel}</span>
                                        <span class="timecode-editable">${hp.timecode}</span>${metadataTag}
                                    </span>
                                    <div class="hit-point-actions">
                                        <button class="icon-btn" onclick="app.jumpToHitPoint(${hp.time})" title="Jump">‚Ü©</button>
                                        <button class="icon-btn" onclick="app.openEditModal('${hp.id}')" title="Edit">‚úé</button>
                                        <button class="icon-btn" onclick="app.deleteHitPoint('${hp.id}')" title="Delete">√ó</button>
                                    </div>
                                </div>
                                <div class="hit-point-note">${hp.note}</div>
                                <div class="hit-point-user">‚Äî ${hp.user || 'Unknown'} ‚Ä¢ ${deptConfig.name}</div>
                            </div>
                        `;
                    }).join('');
                }
                
                this.updateTimelineMarkers();
                
                // Update custom timeline markers
                if (this.updateCustomTimelineMarkers) {
                    this.updateCustomTimelineMarkers();
                }
            },
            
            jumpToHitPoint(time) {
                this.video.currentTime = time;
                this.syncPlaybackState(); // Sync jump to other browsers
            },
            
            async deleteHitPoint(id) {
                this.storage.hitPoints = this.storage.hitPoints.filter(hp => hp.id !== id);
                
                // Delete from Firebase
                if (this.db && this.sessionId) {
                    try {
                        await this.db.collection('sessions').doc(this.sessionId)
                            .collection('markers').doc(id).delete();
                        console.log(`üóëÔ∏è Deleted marker ${id} from Firebase`);
                    } catch (error) {
                        console.error('‚ùå Error deleting marker from Firebase:', error);
                    }
                }
                
                // Save to localStorage
                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                
                await this.refreshHitPoints();
            },
            
            openEditModal(id) {
                const hitPoint = this.storage.hitPoints.find(hp => hp.id === id);
                if (!hitPoint) return;
                
                this.editingEventId = id;
                
                // Populate modal fields
                document.getElementById('editTimecode').value = hitPoint.timecode;
                document.getElementById('editNote').value = hitPoint.note;
                
                // Show/hide music metadata based on department
                const musicMetadata = document.getElementById('editMusicMetadata');
                if (hitPoint.department === 'music') {
                    musicMetadata.classList.remove('hidden');
                    
                    // Set category checkboxes
                    document.querySelectorAll('input[name="edit-category"]').forEach(cb => {
                        cb.checked = (cb.value === hitPoint.category);
                    });
                    
                    // Set usage checkboxes
                    document.querySelectorAll('input[name="edit-usage"]').forEach(cb => {
                        cb.checked = (cb.value === hitPoint.usage);
                    });
                } else {
                    musicMetadata.classList.add('hidden');
                }
                
                // Show modal
                document.getElementById('editModal').classList.remove('hidden');
            },
            
            closeEditModal() {
                document.getElementById('editModal').classList.add('hidden');
                this.editingEventId = null;
            },
            
            async saveEditedEvent() {
                console.log('üíæ saveEditedEvent called');
                console.log('   editingEventId:', this.editingEventId);
                
                if (!this.editingEventId) {
                    console.error('‚ùå No event being edited');
                    alert('Error: No event selected for editing');
                    return;
                }
                
                const hitPoint = this.storage.hitPoints.find(hp => hp.id === this.editingEventId);
                if (!hitPoint) {
                    console.error('‚ùå Event not found:', this.editingEventId);
                    alert('Error: Event not found');
                    return;
                }
                
                console.log('‚úì Found event to edit:', hitPoint);
                
                const newTimecode = document.getElementById('editTimecode').value.trim();
                const newNote = document.getElementById('editNote').value.trim();
                
                // Validate timecode format
                const parts = newTimecode.split(/[:;]/);
                if (parts.length !== 4) {
                    alert('Invalid timecode format. Use HH:MM:SS:FF');
                    return;
                }
                
                // Update event
                const originalTimecode = hitPoint.timecode;
                hitPoint.timecode = newTimecode;
                hitPoint.note = newNote || 'Unmarked marker';
                
                // Mark as manually edited if timecode changed
                if (originalTimecode !== newTimecode) {
                    hitPoint.manuallyEditedTimecode = true;
                }
                
                // Update music metadata if applicable
                if (hitPoint.department === 'music') {
                    const categoryChecked = document.querySelector('input[name="edit-category"]:checked');
                    const usageChecked = document.querySelector('input[name="edit-usage"]:checked');
                    hitPoint.category = categoryChecked ? categoryChecked.value : null;
                    hitPoint.usage = usageChecked ? usageChecked.value : null;
                }
                
                // Save to Firebase
                await this.saveMarkerToFirebase(hitPoint);
                
                // Save to localStorage
                localStorage.setItem('film-spotter-hitpoints-' + this.sessionId, JSON.stringify(this.storage.hitPoints));
                
                this.showMessage('‚úì Event updated');
                this.closeEditModal();
                await this.refreshHitPoints();
            },
            
            togglePasswordField() {
                const checkbox = document.getElementById('enablePassword');
                const passwordField = document.getElementById('sessionPassword');
                
                if (checkbox.checked) {
                    passwordField.classList.remove('hidden');
                } else {
                    passwordField.classList.add('hidden');
                }
            },
            
            toggleParticipantsPanel() {
                const panel = document.getElementById('participantsPanel');
                
                if (panel.classList.contains('hidden')) {
                    this.updateParticipantsList();
                    panel.classList.remove('hidden');
                } else {
                    panel.classList.add('hidden');
                }
            },
            
            updateParticipantsList() {
                const listElement = document.getElementById('participantsList');
                const users = this.activeUsers || [];
                
                if (users.length === 0) {
                    listElement.innerHTML = '<p style="color: #808080; text-align: center;">No participants</p>';
                    return;
                }
                
                listElement.innerHTML = users.map(user => {
                    const isCurrentUser = user.user === this.userName;
                    const role = user.role || 'viewer';
                    const roleLabel = role === 'host' ? '‚≠ê Host' : role === 'co-host' ? 'üëë Co-Host' : 'üë§ Viewer';
                    
                    let actions = '';
                    
                    // Only host can manage others
                    if (this.userRole === 'host' && !isCurrentUser) {
                        if (role === 'co-host') {
                            actions = `
                                <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 11px;" onclick="app.revokeCoHost('${user.user}')">Revoke Control</button>
                                <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" onclick="app.kickUser('${user.user}')">Kick</button>
                            `;
                        } else {
                            actions = `
                                <button class="btn" style="padding: 4px 8px; font-size: 11px;" onclick="app.giveCoHost('${user.user}')">Give Control</button>
                                <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" onclick="app.kickUser('${user.user}')">Kick</button>
                            `;
                        }
                    }
                    
                    return `
                        <div style="background: #1a1a1a; padding: 12px; border-radius: 4px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold; color: ${isCurrentUser ? '#0066cc' : '#e0e0e0'};">
                                        ${user.user}${isCurrentUser ? ' (You)' : ''}
                                    </div>
                                    <div style="font-size: 11px; color: #808080;">${roleLabel}</div>
                                </div>
                                <div style="display: flex; gap: 6px;">
                                    ${actions}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            },
            
            giveCoHost(username) {
                const user = this.activeUsers.find(u => u.user === username);
                if (user) {
                    user.role = 'co-host';
                    this.saveActiveUsers();
                    this.updateParticipantsList();
                    this.showMessage(`‚úì Gave control to ${username}`);
                }
            },
            
            revokeCoHost(username) {
                const user = this.activeUsers.find(u => u.user === username);
                if (user) {
                    user.role = 'viewer';
                    this.saveActiveUsers();
                    this.updateParticipantsList();
                    this.showMessage(`‚úì Revoked control from ${username}`);
                }
            },
            
            kickUser(username) {
                if (confirm(`Kick ${username} from the session?`)) {
                    this.activeUsers = this.activeUsers.filter(u => u.user !== username);
                    this.saveActiveUsers();
                    this.updateParticipantsList();
                    this.showMessage(`‚úì Kicked ${username}`);
                }
            },
            
            saveActiveUsers() {
                localStorage.setItem('film-spotter-users-' + this.sessionId, JSON.stringify(this.activeUsers));
            },
            
            canControl() {
                // Check if current user can control playback and mark events
                if (this.allowAllControl) return true;
                return this.userRole === 'host' || this.userRole === 'co-host';
            },
            
            jumpToFrame(timecode) {
                if (!timecode) {
                    timecode = prompt('Enter timecode to jump to (HH:MM:SS:FF):', '00:00:00:00');
                }
                if (!timecode) return;
                
                // Parse timecode format HH:MM:SS:FF
                const parts = timecode.trim().split(/[:;]/);
                if (parts.length !== 4) {
                    alert('Invalid timecode format. Use HH:MM:SS:FF');
                    this.updateTimecode();
                    return;
                }
                
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                const frames = parseInt(parts[3]) || 0;
                
                // Calculate time in seconds (this includes the offset calculation)
                const targetTime = hours * 3600 + minutes * 60 + seconds + (frames / this.fps);
                
                // Subtract the offset to get the actual video time
                const videoTime = targetTime - this.timecodeOffset;
                
                if (videoTime < 0 || videoTime > this.video.duration) {
                    alert('Timecode is outside video duration');
                    this.updateTimecode();
                    return;
                }
                
                this.video.currentTime = videoTime;
                this.showMessage('‚úì Jumped to ' + timecode);
            },
            
            async sendChat() {
                // Check permission
                if (!this.canChat) {
                    this.showMessage('‚õî You do not have permission to send messages', true);
                    return;
                }
                
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                
                if (!message) {
                    return;
                }
                
                const chatMessage = {
                    id: `${this.userName}-${Date.now()}`, // Unique ID with username prefix
                    text: message,
                    timestamp: new Date().toISOString(), // Use ISO for better sorting
                    user: this.userName
                };
                
                console.log('Sending chat message:', chatMessage);
                
                this.storage.chatMessages.push(chatMessage);
                
                // Save to Firebase IMMEDIATELY as individual document
                try {
                    await this.saveChatToFirebase(chatMessage);
                } catch (error) {
                    // Error already shown by saveChatToFirebase
                    console.error('Failed to save chat to Firebase, but saved locally');
                }
                
                // Also save to localStorage as backup
                localStorage.setItem('film-spotter-chat-' + this.sessionId, JSON.stringify(this.storage.chatMessages));
                
                input.value = '';
                await this.refreshChat();
            },
            
            handleChatEnter(event) {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent form submission
                    this.sendChat().catch(error => {
                        console.error('‚ùå Error in sendChat:', error);
                        alert(`Failed to send message: ${error.message}`);
                    });
                }
            },
            
            getUserColor(username) {
                // Assign colors based on participant order to prevent collisions
                // Store color assignments in memory
                if (!this.userColorMap) {
                    this.userColorMap = {};
                    this.nextColorIndex = 0;
                }
                
                // If user already has a color, return it
                if (this.userColorMap[username]) {
                    return this.userColorMap[username];
                }
                
                // Assign next color in sequence
                const colors = [
                    'hsl(210, 70%, 60%)', // Blue
                    'hsl(30, 70%, 60%)',  // Orange
                    'hsl(120, 70%, 60%)', // Green
                    'hsl(330, 70%, 60%)', // Pink
                    'hsl(270, 70%, 60%)', // Purple
                    'hsl(180, 70%, 60%)', // Cyan
                    'hsl(60, 70%, 60%)',  // Yellow
                    'hsl(300, 70%, 60%)', // Magenta
                    'hsl(15, 70%, 60%)',  // Red-orange
                    'hsl(240, 70%, 60%)', // Blue-purple
                    'hsl(150, 70%, 60%)', // Green-cyan
                    'hsl(345, 70%, 60%)', // Red-pink
                ];
                
                const color = colors[this.nextColorIndex % colors.length];
                this.userColorMap[username] = color;
                this.nextColorIndex++;
                
                console.log(`üé® Assigned ${username} ‚Üí ${color}`);
                
                return color;
            },
            
            async refreshChat() {
                const chatElement = document.getElementById('chatMessages');
                chatElement.innerHTML = this.storage.chatMessages.map(msg => {
                    const userColor = this.getUserColor(msg.user || 'Anonymous');
                    return `
                        <div class="chat-message">
                            <div class="chat-header">
                                <span class="chat-user" style="color: ${userColor}; font-weight: bold;">${msg.user || 'Anonymous'}</span>
                                <span class="chat-timestamp">${msg.timestamp}</span>
                            </div>
                            <div class="chat-text">${msg.text}</div>
                        </div>
                    `;
                }).join('');
                
                chatElement.scrollTop = chatElement.scrollHeight;
            },
            
            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                event.target.classList.add('active');
                
                document.getElementById('hitpointsTab').classList.add('hidden');
                document.getElementById('chatTab').classList.add('hidden');
                
                if (tabName === 'hitpoints') {
                    document.getElementById('hitpointsTab').classList.remove('hidden');
                } else if (tabName === 'chat') {
                    document.getElementById('chatTab').classList.remove('hidden');
                }
            },
            
            async exportData() {
                // Show export format selection modal
                document.getElementById('exportModal').classList.remove('hidden');
            },
            
            closeExportModal() {
                document.getElementById('exportModal').classList.add('hidden');
            },
            
            showUpgradeModal() {
                document.getElementById('exportModal').classList.add('hidden');
                document.getElementById('upgradeModal').classList.remove('hidden');
            },
            
            closeUpgradeModal() {
                document.getElementById('upgradeModal').classList.add('hidden');
            },
            
            joinWaitlist() {
                // For now, just show a message
                // Later this will integrate with email capture
                alert('Thank you for your interest! We\'ll notify you when paid plans launch.\n\nFor now, reach out to support@filmspotter.app to get early access.');
                this.closeUpgradeModal();
            },
            
            createNewSession() {
                if (confirm('Start a new session? This will clear current session data and generate a new session ID.')) {
                    // Clear old listeners FIRST
                    if (this.unsubscribeListeners) {
                        this.unsubscribeListeners.forEach(unsub => unsub());
                        this.unsubscribeListeners = [];
                    }
                    
                    // Clear heartbeat
                    if (this.participantHeartbeat) {
                        clearInterval(this.participantHeartbeat);
                    }
                    
                    // Generate new random session ID
                    const newSessionId = 'session-' + Math.random().toString(36).substr(2, 9);
                    this.sessionId = newSessionId;
                    localStorage.setItem('film-spotter-session-id', newSessionId);
                    
                    // Clear form fields
                    document.getElementById('userNameInput').value = this.userName;
                    document.getElementById('sessionNameInput').value = '';
                    document.getElementById('videoUrlInput').value = '';
                    document.getElementById('projectNameInput').value = '';
                    document.getElementById('sessionPassword').value = '';
                    document.getElementById('enablePassword').checked = false;
                    document.getElementById('sessionPassword').classList.add('hidden');
                    
                    // Update preview
                    document.getElementById('sessionIdDisplay').textContent = newSessionId;
                    document.getElementById('copyLinkBtn').style.display = 'none';
                    
                    // Clear local storage for this session
                    localStorage.removeItem('film-spotter-hitpoints-' + newSessionId);
                    localStorage.removeItem('film-spotter-chat-' + newSessionId);
                    
                    // Clear in-memory data
                    this.storage.hitPoints = [];
                    this.storage.chatMessages = [];
                    
                    // Re-setup Firebase listeners for NEW session
                    if (this.db) {
                        this.setupFirebaseListeners();
                        console.log(`‚úÖ Firebase reconnected to new session: ${newSessionId}`);
                    }
                    
                    this.showMessage('‚úì New session created: ' + newSessionId);
                    console.log('üÜï Created new session:', newSessionId);
                }
            },
            
            async confirmExport() {
                const exportCSV = document.getElementById('exportCSV').checked;
                const exportJSON = document.getElementById('exportJSON').checked;
                const exportEDL = document.getElementById('exportEDL').checked;
                const exportMIDI = document.getElementById('exportMIDI').checked;
                
                if (!exportCSV && !exportJSON && !exportEDL && !exportMIDI) {
                    alert('Please select at least one export format');
                    return;
                }
                
                this.closeExportModal();
                
                const exportFiltered = document.getElementById('exportFiltered').checked;
                
                // Determine which events to export
                let eventsToExport = this.storage.hitPoints;
                
                if (exportFiltered && !this.activeFilters.includes('global')) {
                    eventsToExport = this.storage.hitPoints.filter(hp => 
                        this.activeFilters.includes(hp.department || 'music')
                    );
                }
                
                if (eventsToExport.length === 0) {
                    alert('No events to export');
                    return;
                }
                
                // Get project name for filename
                const projectName = document.getElementById('projectNameInput').value.trim() || 'Untitled';
                const safeProjectName = projectName.replace(/[^a-z0-9]/gi, '_');
                
                // Create CSV export
                const csvContent = [
                    ['Department', 'Type', 'Marker Label', 'Timecode', 'Category', 'Usage', 'Note', 'User'],
                    ...eventsToExport.map(hp => {
                        const dept = hp.department || 'music';
                        const deptConfig = this.departments[dept];
                        const markerConfig = deptConfig.markers.find(m => m.value === hp.type);
                        const markerLabel = markerConfig ? markerConfig.label : hp.type;
                        
                        // Format category and usage
                        const categoryLabels = {
                            'source': 'Source Music',
                            'underscore': 'Underscore'
                        };
                        const usageLabels = {
                            'bg-inst': 'Background Instrumental',
                            'bg-vocal': 'Background Vocal',
                            'vis-inst': 'Visual Instrumental',
                            'vis-vocal': 'Visual Vocal'
                        };
                        
                        const category = hp.category ? categoryLabels[hp.category] : '';
                        const usage = hp.usage ? usageLabels[hp.usage] : '';
                        
                        return [
                            deptConfig.name,
                            hp.type || 'hit-point',
                            markerLabel,
                            hp.timecode,
                            category,
                            usage,
                            `"${hp.note.replace(/"/g, '""')}"`,
                            hp.user || 'Unknown'
                        ];
                    })
                ].map(row => row.join(',')).join('\n');
                
                // Create JSON export
                const jsonContent = JSON.stringify(eventsToExport, null, 2);
                
                // Create EDL export (CMX 3600 format)
                let edlContent = `TITLE: ${projectName}\nFCM: NON-DROP FRAME\n\n`;
                eventsToExport.forEach((hp, index) => {
                    const eventNum = String(index + 1).padStart(3, '0');
                    const dept = hp.department || 'music';
                    const deptConfig = this.departments[dept];
                    const markerConfig = deptConfig.markers.find(m => m.value === hp.type);
                    const markerLabel = markerConfig ? markerConfig.label : hp.type;
                    
                    // EDL format uses source in/out and record in/out
                    // For markers, we use the same timecode for all (since they're points, not clips)
                    const tc = hp.timecode;
                    
                    edlContent += `${eventNum}  AX       V     C        ${tc} ${tc} ${tc} ${tc}\n`;
                    edlContent += `* FROM CLIP NAME: ${markerLabel}\n`;
                    edlContent += `* COMMENT: [${deptConfig.name}] ${hp.note}\n`;
                    if (hp.user) {
                        edlContent += `* USER: ${hp.user}\n`;
                    }
                    edlContent += `\n`;
                });
                
                // Download only selected formats with staggered delays
                let delay = 0;
                
                if (exportCSV) {
                    setTimeout(() => {
                        this.downloadFile(csvContent, `${safeProjectName} - Events List - FilmSpotter.csv`, 'text/csv');
                    }, delay);
                    delay += 500;
                }
                
                if (exportJSON) {
                    setTimeout(() => {
                        this.downloadFile(jsonContent, `${safeProjectName} - Events List - FilmSpotter.json`, 'application/json');
                    }, delay);
                    delay += 500;
                }
                
                if (exportEDL) {
                    setTimeout(() => {
                        this.downloadFile(edlContent, `${safeProjectName} - Events List - FilmSpotter.edl`, 'text/plain');
                    }, delay);
                }
                
                // MIDI Export
                if (exportMIDI) {
                    const midiBytes = this.generateMIDI(eventsToExport);
                    setTimeout(() => {
                        this.downloadFile(midiBytes, `${safeProjectName} - Markers - FilmSpotter.mid`, 'audio/midi');
                    }, delay);
                }
            },
            
            generateMIDI(events) {
                // MIDI File Format (Type 1, single track with markers)
                // Based on Standard MIDI File format 1.0
                
                const ticksPerQuarter = 480; // Standard resolution
                
                // Helper functions for MIDI encoding
                const writeVarLen = (value) => {
                    let buffer = [];
                    buffer.push(value & 0x7F);
                    value >>= 7;
                    while (value > 0) {
                        buffer.unshift((value & 0x7F) | 0x80);
                        value >>= 7;
                    }
                    return buffer;
                };
                
                const writeString = (str) => {
                    return Array.from(new TextEncoder().encode(str));
                };
                
                const write32 = (value) => {
                    return [
                        (value >> 24) & 0xFF,
                        (value >> 16) & 0xFF,
                        (value >> 8) & 0xFF,
                        value & 0xFF
                    ];
                };
                
                const write16 = (value) => {
                    return [
                        (value >> 8) & 0xFF,
                        value & 0xFF
                    ];
                };
                
                // Calculate tempo (microseconds per quarter note for 23.976 fps)
                // Using 120 BPM as base tempo
                const microsecondsPerQuarter = 500000; // 120 BPM
                
                // Build track data
                let trackData = [];
                
                // Track header: Set tempo
                trackData.push(
                    ...writeVarLen(0), // Delta time 0
                    0xFF, 0x51, 0x03, // Meta event: Set Tempo
                    ...write32(microsecondsPerQuarter).slice(1) // 3 bytes for tempo
                );
                
                // Track header: Time signature (4/4)
                trackData.push(
                    ...writeVarLen(0), // Delta time 0
                    0xFF, 0x58, 0x04, // Meta event: Time Signature
                    0x04, 0x02, 0x18, 0x08 // 4/4 time
                );
                
                // Sort events by time
                const sortedEvents = [...events].sort((a, b) => a.time - b.time);
                
                // Add markers for each event
                sortedEvents.forEach((event, index) => {
                    // Convert time in seconds to MIDI ticks
                    // ticks = (seconds * ticksPerQuarter * 1000000) / microsecondsPerQuarter
                    const ticks = Math.round((event.time * ticksPerQuarter * 1000000) / microsecondsPerQuarter);
                    
                    // Delta time from previous event
                    const prevTicks = index > 0 
                        ? Math.round((sortedEvents[index - 1].time * ticksPerQuarter * 1000000) / microsecondsPerQuarter)
                        : 0;
                    const deltaTime = ticks - prevTicks;
                    
                    // Marker text: Use first word of note, or fallback to label
                    let markerText = event.note || '';
                    
                    // Extract first word (before space, dash, comma, etc.)
                    const firstWord = markerText.trim().split(/[\s\-,;:]+/)[0];
                    
                    // Use first word if it exists, otherwise use the label
                    if (firstWord && firstWord !== 'Unmarked') {
                        markerText = firstWord;
                    } else {
                        // Fallback to label if no note or note is just "Unmarked marker"
                        const dept = event.department || 'music';
                        const deptConfig = this.departments[dept];
                        const markerConfig = deptConfig.markers.find(m => m.value === event.type);
                        markerText = markerConfig ? markerConfig.label : event.type;
                    }
                    
                    // MIDI Marker event (FF 06)
                    const markerBytes = writeString(markerText);
                    trackData.push(
                        ...writeVarLen(deltaTime),
                        0xFF, 0x06, // Meta event: Marker
                        markerBytes.length, // Length of marker text
                        ...markerBytes
                    );
                });
                
                // End of track
                trackData.push(
                    ...writeVarLen(0), // Delta time 0
                    0xFF, 0x2F, 0x00 // Meta event: End of Track
                );
                
                // Build complete MIDI file
                const midiFile = [];
                
                // Header chunk
                midiFile.push(
                    0x4D, 0x54, 0x68, 0x64, // "MThd"
                    ...write32(6), // Header length
                    ...write16(0), // Format 0 (single track)
                    ...write16(1), // Number of tracks
                    ...write16(ticksPerQuarter) // Ticks per quarter note
                );
                
                // Track chunk
                midiFile.push(
                    0x4D, 0x54, 0x72, 0x6B, // "MTrk"
                    ...write32(trackData.length), // Track length
                    ...trackData
                );
                
                return new Uint8Array(midiFile);
            },
            
            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            
            async makeHost(participantId) {
                if (!this.isHost) {
                    alert('Only the host can transfer host status');
                    return;
                }
                
                if (!confirm('Transfer host status to this user?')) {
                    return;
                }
                
                try {
                    // Remove host from current host
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(this.myParticipantId).update({
                            isHost: false
                        });
                    
                    // Make new user host
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(participantId).update({
                            isHost: true,
                            canMark: true,
                            canChat: true,
                            canControl: true
                        });
                    
                    this.isHost = false;
                    this.showMessage('‚úì Host status transferred');
                } catch (error) {
                    console.error('Error transferring host:', error);
                    alert('Failed to transfer host status');
                }
            },
            
            async togglePermission(participantId, permission) {
                if (!this.isHost) {
                    alert('Only the host can change permissions');
                    return;
                }
                
                try {
                    // Get current participant data
                    const participantDoc = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(participantId).get();
                    
                    if (!participantDoc.exists) return;
                    
                    const participantData = participantDoc.data();
                    
                    // Map permission type to field name
                    let permField;
                    let permName;
                    if (permission === 'mark') {
                        permField = 'canMark';
                        permName = 'marking';
                    } else if (permission === 'chat') {
                        permField = 'canChat';
                        permName = 'chat';
                    } else if (permission === 'control') {
                        permField = 'canControl';
                        permName = 'playback control';
                    }
                    
                    const newValue = !participantData[permField];
                    
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(participantId).update({
                            [permField]: newValue
                        });
                    
                    const action = newValue ? 'enabled' : 'disabled';
                    this.showMessage(`‚úì ${permName} ${action} for ${participantData.name}`);
                } catch (error) {
                    console.error('Error toggling permission:', error);
                    alert('Failed to change permission');
                }
            },
            
            async kickUser(participantId) {
                if (!this.isHost) {
                    alert('Only the host can kick users');
                    return;
                }
                
                if (!confirm('Kick this user from the session?')) {
                    return;
                }
                
                try {
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(participantId).delete();
                    
                    this.showMessage('‚úì User kicked');
                } catch (error) {
                    console.error('Error kicking user:', error);
                    alert('Failed to kick user');
                }
            },
            
            leaveSession() {
                // Different options for host vs guest
                if (this.isHost) {
                    // Show modal with 3 button choices
                    document.getElementById('leaveSessionModal').classList.remove('hidden');
                } else {
                    // Show guest confirmation modal
                    document.getElementById('guestLeaveModal').classList.remove('hidden');
                }
            },
            
            closeLeaveSessionModal() {
                document.getElementById('leaveSessionModal').classList.add('hidden');
            },
            
            closeGuestLeaveModal() {
                document.getElementById('guestLeaveModal').classList.add('hidden');
            },
            
            confirmLeaveAsGuest() {
                this.closeGuestLeaveModal();
                this.leaveAsGuest();
            },
            
            async endSessionForAll() {
                this.closeLeaveSessionModal();
                
                try {
                    // Delete all markers
                    const markersSnapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('markers').get();
                    const markerDeletes = markersSnapshot.docs.map(doc => doc.ref.delete());
                    await Promise.all(markerDeletes);
                    
                    // Delete all chat
                    const chatSnapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('chat').get();
                    const chatDeletes = chatSnapshot.docs.map(doc => doc.ref.delete());
                    await Promise.all(chatDeletes);
                    
                    // Delete all participants
                    const participantsSnapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').get();
                    const participantDeletes = participantsSnapshot.docs.map(doc => doc.ref.delete());
                    await Promise.all(participantDeletes);
                    
                    // Delete session document
                    await this.db.collection('sessions').doc(this.sessionId).delete();
                    
                    console.log('üóëÔ∏è Session ended for everyone');
                    
                    // Clear local storage
                    localStorage.removeItem('film-spotter-hitpoints-' + this.sessionId);
                    localStorage.removeItem('film-spotter-chat-' + this.sessionId);
                    localStorage.removeItem('film-spotter-session-id');
                    
                    alert('Session ended for all participants');
                    location.reload();
                } catch (error) {
                    console.error('‚ùå Error ending session:', error);
                    alert('Error ending session. Check console.');
                }
            },
            
            async leaveAndTransferHost() {
                this.closeLeaveSessionModal();
                
                try {
                    // Get all other participants
                    const participantsSnapshot = await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').get();
                    
                    const otherParticipants = [];
                    participantsSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.id !== this.myParticipantId) {
                            otherParticipants.push(data);
                        }
                    });
                    
                    if (otherParticipants.length > 0) {
                        // Transfer host to first other participant
                        const newHost = otherParticipants[0];
                        await this.db.collection('sessions').doc(this.sessionId)
                            .collection('participants').doc(newHost.id).update({
                                isHost: true
                            });
                        
                        console.log(`üëë Transferred host to ${newHost.name}`);
                    }
                    
                    // Remove ourselves
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(this.myParticipantId).delete();
                    
                    // Clear heartbeat
                    if (this.participantHeartbeat) {
                        clearInterval(this.participantHeartbeat);
                    }
                    
                    // Clear local storage
                    localStorage.removeItem('film-spotter-session-id');
                    
                    alert('You have left the session. Session continues for others.');
                    location.reload();
                } catch (error) {
                    console.error('‚ùå Error leaving session:', error);
                    alert('Error leaving session. Check console.');
                }
            },
            
            async leaveAsGuest() {
                try {
                    // Remove ourselves from participants
                    await this.db.collection('sessions').doc(this.sessionId)
                        .collection('participants').doc(this.myParticipantId).delete();
                    
                    // Clear heartbeat
                    if (this.participantHeartbeat) {
                        clearInterval(this.participantHeartbeat);
                    }
                    
                    // Clear local storage
                    localStorage.removeItem('film-spotter-session-id');
                    
                    console.log('üëã Left session');
                    location.reload();
                } catch (error) {
                    console.error('‚ùå Error leaving session:', error);
                    alert('Error leaving session. Check console.');
                }
            },
            
            startUpdateLoop() {
                // Refresh chat every 2 seconds
                // Hit points are handled by Firebase realtime listener
                this.updateInterval = setInterval(async () => {
                    await this.refreshChat();
                }, 2000);
            }
        };
        
        // Initialize app when page loads
        window.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>
